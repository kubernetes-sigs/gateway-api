<p>Packages:</p>
<ul>
<li>
<a href="#networking.x-k8s.io%2fv1alpha1">networking.x-k8s.io/v1alpha1</a>
</li>
</ul>
<h2 id="networking.x-k8s.io/v1alpha1">networking.x-k8s.io/v1alpha1</h2>
<p>
<p>Package v1alpha1 contains API Schema definitions for the networking.x-k8s.io
API group.</p>
</p>
Resource Types:
<ul><li>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicy">BackendPolicy</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.Gateway">Gateway</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClass">GatewayClass</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRoute">HTTPRoute</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.TCPRoute">TCPRoute</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.TLSRoute">TLSRoute</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.UDPRoute">UDPRoute</a>
</li></ul>
<h3 id="networking.x-k8s.io/v1alpha1.BackendPolicy">BackendPolicy
</h3>
<p>
<p>BackendPolicy defines policies associated with backends. For the purpose of
this API, a backend is defined as any resource that a route can forward
traffic to. A common example of a backend is a Service. Configuration that is
implementation specific may be represented with similar implementation
specific custom resources.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>BackendPolicy</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicySpec">
BackendPolicySpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of BackendPolicy.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>backendRefs</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendRef">
[]BackendRef
</a>
</em>
</td>
<td>
<p>BackendRefs define which backends this policy should be applied to. This
policy can only apply to backends within the same namespace. If more than
one BackendPolicy targets the same backend, precedence must be given to
the oldest BackendPolicy.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendTLSConfig">
BackendTLSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS is the TLS configuration for these backends.</p>
<p>Support: Extended</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicyStatus">
BackendPolicyStatus
</a>
</em>
</td>
<td>
<p>Status defines the current state of BackendPolicy.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.Gateway">Gateway
</h3>
<p>
<p>Gateway represents an instantiation of a service-traffic handling
infrastructure by binding Listeners to a set of IP addresses.</p>
<p>Implementations should add the <code>gateway-exists-finalizer.networking.x-k8s.io</code>
finalizer on the associated GatewayClass whenever Gateway(s) is running.
This ensures that a GatewayClass associated with a Gateway(s) is not
deleted while in use.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Gateway</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewaySpec">
GatewaySpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of Gateway.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>gatewayClassName</code></br>
<em>
string
</em>
</td>
<td>
<p>GatewayClassName used for this Gateway. This is the name of a
GatewayClass resource.</p>
</td>
</tr>
<tr>
<td>
<code>listeners</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Listener">
[]Listener
</a>
</em>
</td>
<td>
<p>Listeners associated with this Gateway. Listeners define
logical endpoints that are bound on this Gateway&rsquo;s addresses.
At least one Listener MUST be specified.</p>
<p>An implementation MAY group Listeners by Port and then collapse each
group of Listeners into a single Listener if the implementation
determines that the Listeners in the group are &ldquo;compatible&rdquo;. An
implementation MAY also group together and collapse compatible
Listeners belonging to different Gateways.</p>
<p>For example, an implementation might consider Listeners to be
compatible with each other if all of the following conditions are
met:</p>
<ol>
<li><p>Either each Listener within the group specifies the &ldquo;HTTP&rdquo;
Protocol or each Listener within the group specifies either
the &ldquo;HTTPS&rdquo; or &ldquo;TLS&rdquo; Protocol.</p></li>
<li><p>Each Listener within the group specifies a Hostname that is unique
within the group.</p></li>
<li><p>As a special case, one Listener within a group may omit Hostname,
in which case this Listener matches when no other Listener
matches.</p></li>
</ol>
<p>If the implementation does collapse compatible Listeners, the
hostname provided in the incoming client request MUST be
matched to a Listener to find the correct set of Routes.
The incoming hostname MUST be matched using the Hostname
field for each Listener in order of most to least specific.
That is, exact matches must be processed before wildcard
matches.</p>
<p>If this field specifies multiple Listeners that have the same
Port value but are not compatible, the implementation must raise
a &ldquo;Conflicted&rdquo; condition in the Listener status.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>addresses</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayAddress">
[]GatewayAddress
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Addresses requested for this gateway. This is optional and
behavior can depend on the GatewayClass. If a value is set
in the spec and the requested address is invalid, the
GatewayClass MUST indicate this in the associated entry in
GatewayStatus.Addresses.</p>
<p>If no Addresses are specified, the GatewayClass may
schedule the Gateway in an implementation-defined manner,
assigning an appropriate set of Addresses.</p>
<p>The GatewayClass MUST bind all Listeners to every
GatewayAddress that it assigns to the Gateway.</p>
<p>Support: Core</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayStatus">
GatewayStatus
</a>
</em>
</td>
<td>
<p>Status defines the current state of Gateway.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayClass">GatewayClass
</h3>
<p>
<p>GatewayClass describes a class of Gateways available to the user
for creating Gateway resources.</p>
<p>GatewayClass is a Cluster level resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>GatewayClass</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClassSpec">
GatewayClassSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of GatewayClass.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>controller</code></br>
<em>
string
</em>
</td>
<td>
<p>Controller is a domain/path string that indicates the
controller that is managing Gateways of this class.</p>
<p>Example: &ldquo;acme.io/gateway-controller&rdquo;.</p>
<p>This field is not mutable and cannot be empty.</p>
<p>The format of this field is DOMAIN &ldquo;/&rdquo; PATH, where DOMAIN
and PATH are valid Kubernetes names
(<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names">https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</a>).</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>parametersRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.ParametersReference">
ParametersReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ParametersRef is a reference to a resource that contains the configuration
parameters corresponding to the GatewayClass. This is optional if the
controller does not require any additional configuration.</p>
<p>ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
or an implementation-specific custom resource. The resource can be
cluster-scoped or namespace-scoped.</p>
<p>If the referent cannot be found, the GatewayClass&rsquo;s &ldquo;InvalidParameters&rdquo;
status condition will be true.</p>
<p>Support: Custom</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClassStatus">
GatewayClassStatus
</a>
</em>
</td>
<td>
<p>Status defines the current state of GatewayClass.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRoute">HTTPRoute
</h3>
<p>
<p>HTTPRoute is the Schema for the HTTPRoute resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>HTTPRoute</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteSpec">
HTTPRouteSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of HTTPRoute.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
<tr>
<td>
<code>hostnames</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Hostname">
[]Hostname
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Hostnames defines a set of hostname that should match against
the HTTP Host header to select a HTTPRoute to process the request.
Hostname is the fully qualified domain name of a network host,
as defined by RFC 3986. Note the following deviations from the
&ldquo;host&rdquo; part of the URI as defined in the RFC:</p>
<ol>
<li>IPs are not allowed.</li>
<li>The <code>:</code> delimiter is not respected because ports are not allowed.</li>
</ol>
<p>Incoming requests are matched against the hostnames before the
HTTPRoute rules. If no hostname is specified, traffic is routed
based on the HTTPRouteRules.</p>
<p>Hostname can be &ldquo;precise&rdquo; which is a domain name without the terminating
dot of a network host (e.g. &ldquo;foo.example.com&rdquo;) or &ldquo;wildcard&rdquo;, which is
a domain name prefixed with a single wildcard label (e.g. <code>*.example.com</code>).
The wildcard character <code>*</code> must appear by itself as the first DNS
label and matches only a single label.
You cannot have a wildcard label by itself (e.g. Host == <code>*</code>).
Requests will be matched against the Host field in the following order:</p>
<ol>
<li>If Host is precise, the request matches this rule if
the HTTP Host header is equal to Host.</li>
<li>If Host is a wildcard, then the request matches this rule if
the HTTP Host header is to equal to the suffix
(removing the first label) of the wildcard rule.</li>
</ol>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteTLSConfig">
RouteTLSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS defines the TLS certificate to use for Hostnames defined in this
Route. This configuration only takes effect if the AllowRouteOverride
field is set to true in the associated Gateway resource.</p>
<p>Collisions can happen if multiple HTTPRoutes define a TLS certificate
for the same hostname. In such a case, conflict resolution guiding
principles apply, specifically, if hostnames are same and two different
certificates are specified then the certificate in the
oldest resource wins.</p>
<p>Please note that HTTP Route-selection takes place after the
TLS Handshake (ClientHello). Due to this, TLS certificate defined
here will take precedence even if the request has the potential to
match multiple routes (in case multiple HTTPRoutes share the same
hostname).</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteRule">
[]HTTPRouteRule
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Rules are a list of HTTP matchers, filters and actions.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteStatus">
HTTPRouteStatus
</a>
</em>
</td>
<td>
<p>Status defines the current state of HTTPRoute.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TCPRoute">TCPRoute
</h3>
<p>
<p>TCPRoute is the Schema for the TCPRoute resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>TCPRoute</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteSpec">
TCPRouteSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of TCPRoute.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteRule">
[]TCPRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of TCP matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteStatus">
TCPRouteStatus
</a>
</em>
</td>
<td>
<p>Status defines the current state of TCPRoute.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRoute">TLSRoute
</h3>
<p>
<p>The TLSRoute resource is similar to TCPRoute, but can be configured
to match against TLS-specific metadata. This allows more flexibility
in matching streams for a given TLS listener.</p>
<p>If you need to forward traffic to a single target for a TLS listener, you
could choose to use a TCPRoute with a TLS listener.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>TLSRoute</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteSpec">
TLSRouteSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of TLSRoute.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteRule">
[]TLSRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of TLS matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteStatus">
TLSRouteStatus
</a>
</em>
</td>
<td>
<p>Status defines the current state of TLSRoute.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.UDPRoute">UDPRoute
</h3>
<p>
<p>UDPRoute is a resource that specifies how a Gateway should forward UDP traffic.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>UDPRoute</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteSpec">
UDPRouteSpec
</a>
</em>
</td>
<td>
<p>Spec defines the desired state of UDPRoute.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteRule">
[]UDPRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of UDP matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteStatus">
UDPRouteStatus
</a>
</em>
</td>
<td>
<p>Status defines the current state of UDPRoute.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.AddressType">AddressType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayAddress">GatewayAddress</a>)
</p>
<p>
<p>AddressType defines how a network address is represented as a text string.</p>
<p>If the requested address is unsupported, the controller
should raise the &ldquo;Detached&rdquo; listener status condition on
the Gateway with the &ldquo;UnsupportedAddress&rdquo; reason.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;IPAddress&#34;</p></td>
<td><p>A textual representation of a numeric IP address. IPv4
addresses must be in dotted-decimal form. IPv6 addresses
must be in a standard IPv6 text representation
(see <a href="https://tools.ietf.org/html/rfc5952">RFC 5952</a>).</p>
<p>Support: Extended</p>
</td>
</tr><tr><td><p>&#34;NamedAddress&#34;</p></td>
<td><p>An opaque identifier that represents a specific IP address. The
interpretation of the name is dependent on the controller. For
example, a &ldquo;NamedAddress&rdquo; might be a cloud-dependent identifier
for a static or elastic IP.</p>
<p>Support: Implementation-specific</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.BackendPolicyConditionType">BackendPolicyConditionType
(<code>string</code> alias)</p></h3>
<p>
<p>BackendPolicyConditionType is a type of condition used to express the current
state of a BackendPolicy resource.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;NoSuchBackend&#34;</p></td>
<td><p>Indicates that one or more of the the specified backend references could not be resolved.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.BackendPolicySpec">BackendPolicySpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicy">BackendPolicy</a>)
</p>
<p>
<p>BackendPolicySpec defines desired policy for a backend.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>backendRefs</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendRef">
[]BackendRef
</a>
</em>
</td>
<td>
<p>BackendRefs define which backends this policy should be applied to. This
policy can only apply to backends within the same namespace. If more than
one BackendPolicy targets the same backend, precedence must be given to
the oldest BackendPolicy.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendTLSConfig">
BackendTLSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS is the TLS configuration for these backends.</p>
<p>Support: Extended</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.BackendPolicyStatus">BackendPolicyStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicy">BackendPolicy</a>)
</p>
<p>
<p>BackendPolicyStatus defines the observed state of BackendPolicy. Conditions
that are related to a specific Route or Gateway must be placed on the
Route(s) using backends configured by this BackendPolicy.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#condition-v1-meta">
[]Kubernetes meta/v1.Condition
</a>
</em>
</td>
<td>
<p>Conditions describe the current conditions of the BackendPolicy.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.BackendRef">BackendRef
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicySpec">BackendPolicySpec</a>)
</p>
<p>
<p>BackendRef identifies an API object within the same namespace
as the BackendPolicy.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>group</code></br>
<em>
string
</em>
</td>
<td>
<p>Group is the group of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind is the kind of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<p>Name is the name of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Port is the port of the referent. If unspecified, this policy applies to
all ports on the backend.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.BackendTLSConfig">BackendTLSConfig
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicySpec">BackendPolicySpec</a>)
</p>
<p>
<p>BackendTLSConfig describes TLS configuration for a backend.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>certificateAuthorityRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CertificateAuthorityRef is a reference to a resource that includes
trusted CA certificates for the associated backends. If an entry in this
list omits or specifies the empty string for both the group and the
resource, the resource defaults to &ldquo;secrets&rdquo;. An implementation may
support other resources (for example, resource &ldquo;mycertificates&rdquo; in group
&ldquo;networking.acme.io&rdquo;).</p>
<p>When stored in a Secret, certificates must be PEM encoded and specified
within the &ldquo;ca.crt&rdquo; data field of the Secret. Multiple certificates can
be specified, concatenated by new lines.</p>
<p>Support: Extended</p>
</td>
</tr>
<tr>
<td>
<code>options</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Options are a list of key/value pairs to give extended options to the
provider.</p>
<p>Support: Implementation-specific</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayAddress">GatewayAddress
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewaySpec">GatewaySpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.GatewayStatus">GatewayStatus</a>)
</p>
<p>
<p>GatewayAddress describes an address that can be bound to a Gateway.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.AddressType">
AddressType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Type of the address.</p>
<p>Support: Extended</p>
</td>
</tr>
<tr>
<td>
<code>value</code></br>
<em>
string
</em>
</td>
<td>
<p>Value of the address. The validity of the values will depend
on the type and support by the controller.</p>
<p>Examples: <code>1.2.3.4</code>, <code>128::1</code>, <code>my-ip-address</code>.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayAllowType">GatewayAllowType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">RouteGateways</a>)
</p>
<p>
<p>GatewayAllowType specifies which Gateways should be allowed to use a Route.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;All&#34;</p></td>
<td><p>Any Gateway will be able to use this route.</p>
</td>
</tr><tr><td><p>&#34;FromList&#34;</p></td>
<td><p>Only Gateways that have been  specified in GatewayRefs will be able to use this route.</p>
</td>
</tr><tr><td><p>&#34;SameNamespace&#34;</p></td>
<td><p>Only Gateways within the same namespace as the route will be able to use this route.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayClassConditionReason">GatewayClassConditionReason
(<code>string</code> alias)</p></h3>
<p>
<p>GatewayClassConditionReason defines the set of reasons that explain why
a particular GatewayClass condition type has been raised.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;InvalidParameters&#34;</p></td>
<td><p>This reason is used with the &ldquo;Admitted&rdquo; condition when the
GatewayClass was not admitted because the parametersRef field
was invalid, with more detail in the message.</p>
</td>
</tr><tr><td><p>&#34;Waiting&#34;</p></td>
<td><p>This reason is used with the &ldquo;Admitted&rdquo; condition when the
requested controller has not yet made a decision about whether
to admit the GatewayClass. It is the default Reason on a new
GatewayClass. It indicates</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayClassConditionType">GatewayClassConditionType
(<code>string</code> alias)</p></h3>
<p>
<p>GatewayClassConditionType is the type for status conditions on
Gateway resources. This type should be used with the
GatewayClassStatus.Conditions field.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;Admitted&#34;</p></td>
<td><p>This condition indicates whether the GatewayClass has been
admitted by the controller requested in the <code>spec.controller</code>
field.</p>
<p>This condition defaults to False, and MUST be set by a controller when it sees
a GatewayClass using its controller string.
The status of this condition MUST be set to true if the controller will support
provisioning Gateways using this class. Otherwise, this status MUST be set to false.
If the status is set to false, the controller SHOULD set a Message and Reason as an
explanation.</p>
<p>Controllers should prefer to use the values of GatewayClassConditionReason
for the corresponding Reason, where appropriate.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayClassSpec">GatewayClassSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClass">GatewayClass</a>)
</p>
<p>
<p>GatewayClassSpec reflects the configuration of a class of Gateways.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>controller</code></br>
<em>
string
</em>
</td>
<td>
<p>Controller is a domain/path string that indicates the
controller that is managing Gateways of this class.</p>
<p>Example: &ldquo;acme.io/gateway-controller&rdquo;.</p>
<p>This field is not mutable and cannot be empty.</p>
<p>The format of this field is DOMAIN &ldquo;/&rdquo; PATH, where DOMAIN
and PATH are valid Kubernetes names
(<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names">https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</a>).</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>parametersRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.ParametersReference">
ParametersReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ParametersRef is a reference to a resource that contains the configuration
parameters corresponding to the GatewayClass. This is optional if the
controller does not require any additional configuration.</p>
<p>ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
or an implementation-specific custom resource. The resource can be
cluster-scoped or namespace-scoped.</p>
<p>If the referent cannot be found, the GatewayClass&rsquo;s &ldquo;InvalidParameters&rdquo;
status condition will be true.</p>
<p>Support: Custom</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayClassStatus">GatewayClassStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClass">GatewayClass</a>)
</p>
<p>
<p>GatewayClassStatus is the current status for the GatewayClass.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#condition-v1-meta">
[]Kubernetes meta/v1.Condition
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Conditions is the current status from the controller for
this GatewayClass.</p>
<p>Controllers should prefer to publish conditions using values
of GatewayClassConditionType for the type of each Condition.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayConditionReason">GatewayConditionReason
(<code>string</code> alias)</p></h3>
<p>
<p>GatewayConditionReason defines the set of reasons that explain
why a particular Gateway condition type has been raised.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;AddressNotAssigned&#34;</p></td>
<td><p>This reason is used with the &ldquo;Ready&rdquo; condition when the requested
address has not been assigned to the Gateway. This reason
can be used to express a range of circumstances, including
(but not limited to) IPAM address exhaustion, invalid
or unsupported address requests, or a named address not
being found.</p>
</td>
</tr><tr><td><p>&#34;ListenersNotReady&#34;</p></td>
<td><p>This reason is used with the &ldquo;Ready&rdquo; condition when one or
more Listeners are not ready to serve traffic.</p>
</td>
</tr><tr><td><p>&#34;ListenersNotValid&#34;</p></td>
<td><p>This reason is used with the &ldquo;Ready&rdquo; condition when one or
more Listeners have an invalid or unsupported configuration
and cannot be configured on the Gateway.</p>
</td>
</tr><tr><td><p>&#34;NoResources&#34;</p></td>
<td><p>This reason is used with the &ldquo;Scheduled&rdquo; condition when the
Gateway is not scheduled because insufficient infrastructure
resources are available.</p>
</td>
</tr><tr><td><p>&#34;NoSuchGatewayClass&#34;</p></td>
<td><p>This reason is used with the &ldquo;Scheduled&rdquo; condition when the Gateway
is not scheduled because there is no controller that recognizes
the GatewayClassName. This reason should only be set by
a controller that has cluster-wide visibility of all the
installed GatewayClasses.</p>
</td>
</tr><tr><td><p>&#34;NotReconciled&#34;</p></td>
<td><p>This reason is used with the &ldquo;Scheduled&rdquo; condition when
been recently created and no controller has reconciled it yet.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayConditionType">GatewayConditionType
(<code>string</code> alias)</p></h3>
<p>
<p>GatewayConditionType is a type of condition associated with a
Gateway. This type should be used with the GatewayStatus.Conditions
field.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;Ready&#34;</p></td>
<td><p>This condition is true when the Gateway is expected to be able
to serve traffic. Note that this does not indicate that the
Gateway configuration is current or even complete (e.g. the
controller may still not have reconciled the latest version,
or some parts of the configuration could be missing).</p>
<p>If both the &ldquo;ListenersNotValid&rdquo; and &ldquo;ListenersNotReady&rdquo;
reasons are true, the Gateway controller should prefer the
&ldquo;ListenersNotValid&rdquo; reason.</p>
<p>Possible reasons for this condition to be false are:</p>
<ul>
<li>&ldquo;ListenersNotValid&rdquo;</li>
<li>&ldquo;ListenersNotReady&rdquo;</li>
<li>&ldquo;AddressNotAssigned&rdquo;</li>
</ul>
<p>Controllers may raise this condition with other reasons,
but should prefer to use the reasons listed above to improve
interoperability.</p>
</td>
</tr><tr><td><p>&#34;Scheduled&#34;</p></td>
<td><p>This condition is true when the controller managing the
Gateway has scheduled the Gateway to the underlying network
infrastructure.</p>
<p>Possible reasons for this condition to be false are:</p>
<ul>
<li>&ldquo;NotReconciled&rdquo;</li>
<li>&ldquo;NoSuchGatewayClass&rdquo;</li>
<li>&ldquo;NoResources&rdquo;</li>
</ul>
<p>Controllers may raise this condition with other reasons,
but should prefer to use the reasons listed above to improve
interoperability.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayReference">GatewayReference
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGatewayStatus">RouteGatewayStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">RouteGateways</a>)
</p>
<p>
<p>GatewayReference identifies a Gateway in a specified namespace.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<p>Name is the name of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>namespace</code></br>
<em>
string
</em>
</td>
<td>
<p>Namespace is the namespace of the referent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewaySpec">GatewaySpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.Gateway">Gateway</a>)
</p>
<p>
<p>GatewaySpec defines the desired state of Gateway.</p>
<p>Not all possible combinations of options specified in the Spec are
valid. Some invalid configurations can be caught synchronously via a
webhook, but there are many cases that will require asynchronous
signaling via the GatewayStatus block.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>gatewayClassName</code></br>
<em>
string
</em>
</td>
<td>
<p>GatewayClassName used for this Gateway. This is the name of a
GatewayClass resource.</p>
</td>
</tr>
<tr>
<td>
<code>listeners</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Listener">
[]Listener
</a>
</em>
</td>
<td>
<p>Listeners associated with this Gateway. Listeners define
logical endpoints that are bound on this Gateway&rsquo;s addresses.
At least one Listener MUST be specified.</p>
<p>An implementation MAY group Listeners by Port and then collapse each
group of Listeners into a single Listener if the implementation
determines that the Listeners in the group are &ldquo;compatible&rdquo;. An
implementation MAY also group together and collapse compatible
Listeners belonging to different Gateways.</p>
<p>For example, an implementation might consider Listeners to be
compatible with each other if all of the following conditions are
met:</p>
<ol>
<li><p>Either each Listener within the group specifies the &ldquo;HTTP&rdquo;
Protocol or each Listener within the group specifies either
the &ldquo;HTTPS&rdquo; or &ldquo;TLS&rdquo; Protocol.</p></li>
<li><p>Each Listener within the group specifies a Hostname that is unique
within the group.</p></li>
<li><p>As a special case, one Listener within a group may omit Hostname,
in which case this Listener matches when no other Listener
matches.</p></li>
</ol>
<p>If the implementation does collapse compatible Listeners, the
hostname provided in the incoming client request MUST be
matched to a Listener to find the correct set of Routes.
The incoming hostname MUST be matched using the Hostname
field for each Listener in order of most to least specific.
That is, exact matches must be processed before wildcard
matches.</p>
<p>If this field specifies multiple Listeners that have the same
Port value but are not compatible, the implementation must raise
a &ldquo;Conflicted&rdquo; condition in the Listener status.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>addresses</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayAddress">
[]GatewayAddress
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Addresses requested for this gateway. This is optional and
behavior can depend on the GatewayClass. If a value is set
in the spec and the requested address is invalid, the
GatewayClass MUST indicate this in the associated entry in
GatewayStatus.Addresses.</p>
<p>If no Addresses are specified, the GatewayClass may
schedule the Gateway in an implementation-defined manner,
assigning an appropriate set of Addresses.</p>
<p>The GatewayClass MUST bind all Listeners to every
GatewayAddress that it assigns to the Gateway.</p>
<p>Support: Core</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayStatus">GatewayStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.Gateway">Gateway</a>)
</p>
<p>
<p>GatewayStatus defines the observed state of Gateway.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>addresses</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayAddress">
[]GatewayAddress
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Addresses lists the IP addresses that have actually been
bound to the Gateway. These addresses may differ from the
addresses in the Spec, e.g. if the Gateway automatically
assigns an address from a reserved pool.</p>
<p>These addresses should all be of type &ldquo;IPAddress&rdquo;.</p>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#condition-v1-meta">
[]Kubernetes meta/v1.Condition
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Conditions describe the current conditions of the Gateway.</p>
<p>Implementations should prefer to express Gateway conditions
using the <code>GatewayConditionType</code> and <code>GatewayConditionReason</code>
constants so that operators and tools can converge on a common
vocabulary to describe Gateway state.</p>
<p>Known condition types are:</p>
<ul>
<li>&ldquo;Scheduled&rdquo;</li>
<li>&ldquo;Ready&rdquo;</li>
</ul>
</td>
</tr>
<tr>
<td>
<code>listeners</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.ListenerStatus">
[]ListenerStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Listeners provide status for each unique listener port defined in the Spec.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayTLSConfig">GatewayTLSConfig
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.Listener">Listener</a>)
</p>
<p>
<p>GatewayTLSConfig describes a TLS configuration.</p>
<p>References:</p>
<ul>
<li>nginx: <a href="https://nginx.org/en/docs/http/configuring_https_servers.html">https://nginx.org/en/docs/http/configuring_https_servers.html</a></li>
<li>envoy: <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto">https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto</a></li>
<li>haproxy: <a href="https://www.haproxy.com/documentation/aloha/9-5/traffic-management/lb-layer7/tls/">https://www.haproxy.com/documentation/aloha/9-5/traffic-management/lb-layer7/tls/</a></li>
<li>gcp: <a href="https://cloud.google.com/load-balancing/docs/use-ssl-policies#creating_an_ssl_policy_with_a_custom_profile">https://cloud.google.com/load-balancing/docs/use-ssl-policies#creating_an_ssl_policy_with_a_custom_profile</a></li>
<li>aws: <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies</a></li>
<li>azure: <a href="https://docs.microsoft.com/en-us/azure/app-service/configure-ssl-bindings#enforce-tls-1112">https://docs.microsoft.com/en-us/azure/app-service/configure-ssl-bindings#enforce-tls-1112</a></li>
</ul>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>mode</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSModeType">
TLSModeType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Mode defines the TLS behavior for the TLS session initiated by the client.
There are two possible modes:
- Terminate: The TLS session between the downstream client
and the Gateway is terminated at the Gateway. This mode requires
certificateRef to be set.
- Passthrough: The TLS session is NOT terminated by the Gateway. This
implies that the Gateway can&rsquo;t decipher the TLS stream except for
the ClientHello message of the TLS protocol.
CertificateRef field is ignored in this mode.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>certificateRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CertificateRef is the reference to Kubernetes object that contain a
TLS certificate and private key. This certificate MUST be used for
TLS handshakes for the domain this GatewayTLSConfig is associated with.</p>
<p>This field is required when mode is set to &ldquo;Terminate&rdquo; (default) and
optional otherwise.</p>
<p>If an entry in this list omits or specifies the empty string for both
the group and the resource, the resource defaults to &ldquo;secrets&rdquo;. An
implementation may support other resources (for example, resource
&ldquo;mycertificates&rdquo; in group &ldquo;networking.acme.io&rdquo;).</p>
<p>Support: Core (Kubernetes Secrets)</p>
<p>Support: Implementation-specific (Other resource types)</p>
</td>
</tr>
<tr>
<td>
<code>routeOverride</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSOverridePolicy">
TLSOverridePolicy
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>RouteOverride dictates if TLS settings can be configured
via Routes or not.</p>
<p>CertificateRef must be defined even if <code>routeOverride.certificate</code> is
set to &lsquo;Allow&rsquo; as it will be used as the default certificate for the
listener.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>options</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Options are a list of key/value pairs to give extended options
to the provider.</p>
<p>There variation among providers as to how ciphersuites are
expressed. If there is a common subset for expressing ciphers
then it will make sense to loft that as a core API
construct.</p>
<p>Support: Implementation-specific</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPHeaderMatch">HTTPHeaderMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteMatch">HTTPRouteMatch</a>)
</p>
<p>
<p>HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
headers.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HeaderMatchType">
HeaderMatchType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Type specifies how to match against the value of the header.</p>
<p>Support: Core (Exact)</p>
<p>Support: Custom (RegularExpression, ImplementationSpecific)</p>
<p>Since RegularExpression PathType has custom conformance, implementations
can support POSIX, PCRE or any other dialects of regular expressions.
Please read the implementation&rsquo;s documentation to determine the supported
dialect.</p>
<p>HTTP Header name matching MUST be case-insensitive (RFC 2616 - section 4.2).</p>
</td>
</tr>
<tr>
<td>
<code>values</code></br>
<em>
map[string]string
</em>
</td>
<td>
<p>Values is a map of HTTP Headers to be matched.
It MUST contain at least one entry.</p>
<p>The HTTP header field name to match is the map key, and the
value of the HTTP header is the map value. HTTP header field name matching
MUST be case-insensitive.</p>
<p>Multiple match values are ANDed together, meaning, a request
must match all the specified headers to select the route.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPPathMatch">HTTPPathMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteMatch">HTTPRouteMatch</a>)
</p>
<p>
<p>HTTPPathMatch describes how to select a HTTP route by matching the HTTP request path.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PathMatchType">
PathMatchType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Type specifies how to match against the path Value.</p>
<p>Support: Core (Exact, Prefix)</p>
<p>Support: Custom (RegularExpression, ImplementationSpecific)</p>
<p>Since RegularExpression PathType has custom conformance, implementations
can support POSIX, PCRE or any other dialects of regular expressions.
Please read the implementation&rsquo;s documentation to determine the supported
dialect.</p>
</td>
</tr>
<tr>
<td>
<code>value</code></br>
<em>
string
</em>
</td>
<td>
<p>Value of the HTTP path to match against.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRequestHeaderFilter">HTTPRequestHeaderFilter
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">HTTPRouteFilter</a>)
</p>
<p>
<p>HTTPRequestHeaderFilter defines configuration for the RequestHeaderModifier
filter.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>set</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Set overwrites the request with the given header (name, value)
before the action.</p>
<p>Input:
GET /foo HTTP/1.1
my-header: foo</p>
<p>Config:
set: {&ldquo;my-header&rdquo;: &ldquo;bar&rdquo;}</p>
<p>Output:
GET /foo HTTP/1.1
my-header: bar</p>
<p>Support: Extended</p>
</td>
</tr>
<tr>
<td>
<code>add</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Add adds the given header (name, value) to the request
before the action. It appends to any existing values associated
with the header name.</p>
<p>Input:
GET /foo HTTP/1.1
my-header: foo</p>
<p>Config:
add: {&ldquo;my-header&rdquo;: &ldquo;bar&rdquo;}</p>
<p>Output:
GET /foo HTTP/1.1
my-header: foo
my-header: bar</p>
<p>Support: Extended</p>
</td>
</tr>
<tr>
<td>
<code>remove</code></br>
<em>
[]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Remove the given header(s) from the HTTP request before the
action. The value of RemoveHeader is a list of HTTP header
names. Note that the header names are case-insensitive
[RFC-2616 4.2].</p>
<p>Input:
GET /foo HTTP/1.1
my-header1: foo
my-header2: bar
my-header3: baz</p>
<p>Config:
remove: [&ldquo;my-header1&rdquo;, &ldquo;my-header3&rdquo;]</p>
<p>Output:
GET /foo HTTP/1.1
my-header2: bar</p>
<p>Support: Extended</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRequestMirrorFilter">HTTPRequestMirrorFilter
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">HTTPRouteFilter</a>)
</p>
<p>
<p>HTTPRequestMirrorFilter defines configuration for the RequestMirror filter.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceName refers to the name of the Service to mirror matched requests
to. When specified, this takes the place of BackendRef. If both
BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the rule is not included in the route.
The controller should raise the &ldquo;ResolvedRefs&rdquo; condition on the Gateway
with the &ldquo;DegradedRoutes&rdquo; reason. The gateway status for this route should
be updated with a condition that describes the error more specifically.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>backendRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>BackendRef is a local object reference to mirror matched requests to. If
both BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the rule is not included in the route.
The controller should raise the &ldquo;ResolvedRefs&rdquo; condition on the Gateway
with the &ldquo;DegradedRoutes&rdquo; reason. The gateway status for this route should
be updated with a condition that describes the error more specifically.</p>
<p>Support: Custom</p>
</td>
</tr>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Port specifies the destination port number to use for the
backend referenced by the ServiceName or BackendRef field.</p>
<p>If unspecified, the destination port in the request is used
when forwarding to a backendRef or serviceName.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteFilter">HTTPRouteFilter
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteForwardTo">HTTPRouteForwardTo</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteRule">HTTPRouteRule</a>)
</p>
<p>
<p>HTTPRouteFilter defines additional processing steps that must be completed
during the request or response lifecycle. HTTPRouteFilters are meant as an
extension point to express additional processing that may be done in Gateway
implementations. Some examples include request or response modification,
implementing authentication strategies, rate-limiting, and traffic shaping.
API guarantee/conformance is defined based on the type of the filter.
TODO(hbagdi): re-render CRDs once controller-tools supports union tags:
- <a href="https://github.com/kubernetes-sigs/controller-tools/pull/298">https://github.com/kubernetes-sigs/controller-tools/pull/298</a>
- <a href="https://github.com/kubernetes-sigs/controller-tools/issues/461">https://github.com/kubernetes-sigs/controller-tools/issues/461</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilterType">
HTTPRouteFilterType
</a>
</em>
</td>
<td>
<p>Type identifies the type of filter to apply. As with other API fields,
types are classified into three conformance levels:</p>
<ul>
<li><p>Core: Filter types and their corresponding configuration defined by
&ldquo;Support: Core&rdquo; in this package, e.g. &ldquo;RequestHeaderModifier&rdquo;. All
implementations must support core filters.</p></li>
<li><p>Extended: Filter types and their corresponding configuration defined by
&ldquo;Support: Extended&rdquo; in this package, e.g. &ldquo;RequestMirror&rdquo;. Implementers
are encouraged to support extended filters.</p></li>
<li><p>Custom: Filters that are defined and supported by specific vendors.
In the future, filters showing convergence in behavior across multiple
implementations will be considered for inclusion in extended or core
conformance levels. Filter-specific configuration for such filters
is specified using the ExtensionRef field. <code>Type</code> should be set to
&ldquo;ExtensionRef&rdquo; for custom filters.</p></li>
</ul>
<p>Implementers are encouraged to define custom implementation types to
extend the core API with implementation-specific behavior.</p>
</td>
</tr>
<tr>
<td>
<code>requestHeaderModifier</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRequestHeaderFilter">
HTTPRequestHeaderFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>RequestHeaderModifier defines a schema for a filter that modifies request
headers.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>requestMirror</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRequestMirrorFilter">
HTTPRequestMirrorFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>RequestMirror defines a schema for a filter that mirrors requests.</p>
<p>Support: Extended</p>
</td>
</tr>
<tr>
<td>
<code>extensionRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ExtensionRef is an optional, implementation-specific extension to the
&ldquo;filter&rdquo; behavior.  For example, resource &ldquo;myroutefilter&rdquo; in group
&ldquo;networking.acme.io&rdquo;). ExtensionRef MUST NOT be used for core and
extended filters.</p>
<p>Support: Implementation-specific</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteFilterType">HTTPRouteFilterType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">HTTPRouteFilter</a>)
</p>
<p>
<p>HTTPRouteFilterType identifies a type of HTTPRoute filter.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;ExtensionRef&#34;</p></td>
<td><p>HTTPRouteFilterExtensionRef should be used for configuring custom
HTTP filters.</p>
<p>Support in HTTPRouteRule: Custom</p>
<p>Support in HTTPRouteForwardTo: Custom</p>
</td>
</tr><tr><td><p>&#34;RequestHeaderModifier&#34;</p></td>
<td><p>HTTPRouteFilterRequestHeaderModifier can be used to add or remove an HTTP
header from an HTTP request before it is sent to the upstream target.</p>
<p>Support in HTTPRouteRule: Core</p>
<p>Support in HTTPRouteForwardTo: Extended</p>
</td>
</tr><tr><td><p>&#34;RequestMirror&#34;</p></td>
<td><p>HTTPRouteFilterRequestMirror can be used to mirror HTTP requests to a
different backend. The responses from this backend MUST be ignored by
the Gateway.</p>
<p>Support in HTTPRouteRule: Extended</p>
<p>Support in HTTPRouteForwardTo: Extended</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteForwardTo">HTTPRouteForwardTo
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteRule">HTTPRouteRule</a>)
</p>
<p>
<p>HTTPRouteForwardTo defines how a HTTPRoute should forward a request.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceName refers to the name of the Service to forward matched requests
to. When specified, this takes the place of BackendRef. If both
BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the route must be dropped
from the Gateway. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DegradedRoutes&rdquo; reason.
The gateway status for this route should be updated with a
condition that describes the error more specifically.</p>
<p>The protocol to use should be specified with the AppProtocol field on Service
resources. This field was introduced in Kubernetes 1.18. If using an earlier version
of Kubernetes, a <code>networking.x-k8s.io/app-protocol</code> annotation on the
BackendPolicy resource may be used to define the protocol. If the
AppProtocol field is available, this annotation should not be used. The
AppProtocol field, when populated, takes precedence over the annotation
in the BackendPolicy resource. For custom backends, it is encouraged to
add a semantically-equivalent field in the Custom Resource Definition.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>backendRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>BackendRef is a reference to a backend to forward matched requests to. If
both BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the route must be dropped
from the Gateway. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DegradedRoutes&rdquo; reason.
The gateway status for this route should be updated with a
condition that describes the error more specifically.</p>
<p>Support: Custom</p>
</td>
</tr>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Port specifies the destination port number to use for the
backend referenced by the ServiceName or BackendRef field.
If unspecified, the destination port in the request is used
when forwarding to a backendRef or serviceName.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>weight</code></br>
<em>
int32
</em>
</td>
<td>
<em>(Optional)</em>
<p>Weight specifies the proportion of HTTP requests forwarded to the backend
referenced by the ServiceName or BackendRef field. This is computed as
weight/(sum of all weights in this ForwardTo list). For non-zero values,
there may be some epsilon from the exact proportion defined here
depending on the precision an implementation supports. Weight is not a
percentage and the sum of weights does not need to equal 100.</p>
<p>If only one backend is specified and it has a weight greater than 0, 100%
of the traffic is forwarded to that backend. If weight is set to 0, no
traffic should be forwarded for this entry. If unspecified, weight
defaults to 1.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>filters</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">
[]HTTPRouteFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Filters defined at this-level should be executed if and only if the
request is being forwarded to the backend defined here.</p>
<p>Support: Custom (For broader support of filters, use the Filters field
in HTTPRouteRule.)</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteMatch">HTTPRouteMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteRule">HTTPRouteRule</a>)
</p>
<p>
<p>HTTPRouteMatch defines the predicate used to match requests to a given
action. Multiple match types are ANDed together, i.e. the match will
evaluate to true only if all conditions are satisfied.</p>
<p>For example, the match below will match a HTTP request only if its path
starts with <code>/foo</code> AND it contains the <code>version: &quot;1&quot;</code> header:</p>
<pre><code>match:
path:
value: &quot;/foo&quot;
headers:
values:
version: &quot;1&quot;
</code></pre>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>path</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPPathMatch">
HTTPPathMatch
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Path specifies a HTTP request path matcher. If this field is not
specified, a default prefix match on the &ldquo;/&rdquo; path is provided.</p>
</td>
</tr>
<tr>
<td>
<code>headers</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPHeaderMatch">
HTTPHeaderMatch
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Headers specifies a HTTP request header matcher.</p>
</td>
</tr>
<tr>
<td>
<code>extensionRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ExtensionRef is an optional, implementation-specific extension to the
&ldquo;match&rdquo; behavior. For example, resource &ldquo;myroutematcher&rdquo; in group
&ldquo;networking.acme.io&rdquo;. If the referent cannot be found, the rule is not
included in the route. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DegradedRoutes&rdquo; reason. The gateway
status for this route should be updated with a condition that describes
the error more specifically.</p>
<p>Support: Custom</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteRule">HTTPRouteRule
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteSpec">HTTPRouteSpec</a>)
</p>
<p>
<p>HTTPRouteRule defines semantics for matching an HTTP request based on
conditions, optionally executing additional processing steps, and forwarding
the request to an API object.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>matches</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteMatch">
[]HTTPRouteMatch
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Matches define conditions used for matching the rule against
incoming HTTP requests.
Each match is independent, i.e. this rule will be matched
if <strong>any</strong> one of the matches is satisfied.</p>
<p>For example, take the following matches configuration:</p>
<pre><code>matches:
- path:
value: &quot;/foo&quot;
headers:
values:
version: &quot;2&quot;
- path:
value: &quot;/v2/foo&quot;
</code></pre>
<p>For a request to match against this rule, a request should satisfy
EITHER of the two conditions:</p>
<ul>
<li>path prefixed with <code>/foo</code> AND contains the header <code>version: &quot;2&quot;</code></li>
<li>path prefix of <code>/v2/foo</code></li>
</ul>
<p>See the documentation for HTTPRouteMatch on how to specify multiple
match conditions that should be ANDed together.</p>
<p>If no matches are specified, the default is a prefix
path match on &ldquo;/&rdquo;, which has the effect of matching every
HTTP request.</p>
<p>A client request may match multiple HTTP route rules. Matching precedence
MUST be determined in order of the following criteria, continuing on ties:</p>
<ul>
<li>The longest matching hostname.</li>
<li>The longest matching path.</li>
<li>The largest number of header matches</li>
<li>The oldest Route based on creation timestamp. For example, a Route with
a creation timestamp of &ldquo;2020-09-08 01:02:03&rdquo; is given precedence over
a Route with a creation timestamp of &ldquo;2020-09-08 01:02:04&rdquo;.</li>
<li>The Route appearing first in alphabetical order (namespace/name) for
example, foo/bar is given precedence over foo/baz.</li>
</ul>
</td>
</tr>
<tr>
<td>
<code>filters</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">
[]HTTPRouteFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Filters define the filters that are applied to requests that match
this rule.</p>
<p>The effects of ordering of multiple behaviors are currently unspecified.
This can change in the future based on feedback during the alpha stage.</p>
<p>Conformance-levels at this level are defined based on the type of filter:</p>
<ul>
<li>ALL core filters MUST be supported by all implementations.</li>
<li>Implementers are encouraged to support extended filters.</li>
<li>Implementation-specific custom filters have no API guarantees across
implementations.</li>
</ul>
<p>Specifying a core filter multiple times has unspecified or custom conformance.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>forwardTo</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteForwardTo">
[]HTTPRouteForwardTo
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ForwardTo defines the backend(s) where matching requests should be sent.
If unspecified, the rule performs no forwarding. If unspecified and no
filters are specified that would result in a response being sent, a 503
error code is returned.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteSpec">HTTPRouteSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRoute">HTTPRoute</a>)
</p>
<p>
<p>HTTPRouteSpec defines the desired state of HTTPRoute</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
<tr>
<td>
<code>hostnames</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Hostname">
[]Hostname
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Hostnames defines a set of hostname that should match against
the HTTP Host header to select a HTTPRoute to process the request.
Hostname is the fully qualified domain name of a network host,
as defined by RFC 3986. Note the following deviations from the
&ldquo;host&rdquo; part of the URI as defined in the RFC:</p>
<ol>
<li>IPs are not allowed.</li>
<li>The <code>:</code> delimiter is not respected because ports are not allowed.</li>
</ol>
<p>Incoming requests are matched against the hostnames before the
HTTPRoute rules. If no hostname is specified, traffic is routed
based on the HTTPRouteRules.</p>
<p>Hostname can be &ldquo;precise&rdquo; which is a domain name without the terminating
dot of a network host (e.g. &ldquo;foo.example.com&rdquo;) or &ldquo;wildcard&rdquo;, which is
a domain name prefixed with a single wildcard label (e.g. <code>*.example.com</code>).
The wildcard character <code>*</code> must appear by itself as the first DNS
label and matches only a single label.
You cannot have a wildcard label by itself (e.g. Host == <code>*</code>).
Requests will be matched against the Host field in the following order:</p>
<ol>
<li>If Host is precise, the request matches this rule if
the HTTP Host header is equal to Host.</li>
<li>If Host is a wildcard, then the request matches this rule if
the HTTP Host header is to equal to the suffix
(removing the first label) of the wildcard rule.</li>
</ol>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteTLSConfig">
RouteTLSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS defines the TLS certificate to use for Hostnames defined in this
Route. This configuration only takes effect if the AllowRouteOverride
field is set to true in the associated Gateway resource.</p>
<p>Collisions can happen if multiple HTTPRoutes define a TLS certificate
for the same hostname. In such a case, conflict resolution guiding
principles apply, specifically, if hostnames are same and two different
certificates are specified then the certificate in the
oldest resource wins.</p>
<p>Please note that HTTP Route-selection takes place after the
TLS Handshake (ClientHello). Due to this, TLS certificate defined
here will take precedence even if the request has the potential to
match multiple routes (in case multiple HTTPRoutes share the same
hostname).</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteRule">
[]HTTPRouteRule
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Rules are a list of HTTP matchers, filters and actions.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteStatus">HTTPRouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRoute">HTTPRoute</a>)
</p>
<p>
<p>HTTPRouteStatus defines the observed state of HTTPRoute.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>RouteStatus</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HeaderMatchType">HeaderMatchType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPHeaderMatch">HTTPHeaderMatch</a>)
</p>
<p>
<p>HeaderMatchType specifies the semantics of how HTTP header values should be
compared. Valid HeaderMatchType values are:</p>
<ul>
<li>&ldquo;Exact&rdquo;</li>
<li>&ldquo;RegularExpression&rdquo;</li>
<li>&ldquo;ImplementationSpecific&rdquo;</li>
</ul>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;Exact&#34;</p></td>
<td></td>
</tr><tr><td><p>&#34;ImplementationSpecific&#34;</p></td>
<td></td>
</tr><tr><td><p>&#34;RegularExpression&#34;</p></td>
<td></td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.Hostname">Hostname
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteSpec">HTTPRouteSpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.Listener">Listener</a>, 
<a href="#networking.x-k8s.io/v1alpha1.ListenerStatus">ListenerStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteMatch">TLSRouteMatch</a>)
</p>
<p>
<p>Hostname is used to specify a hostname that should be matched.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.Listener">Listener
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewaySpec">GatewaySpec</a>)
</p>
<p>
<p>Listener embodies the concept of a logical endpoint where a Gateway can
accept network connections. Each listener in a Gateway must have a unique
combination of Hostname, Port, and Protocol. This will be enforced by a
validating webhook.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>hostname</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Hostname">
Hostname
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Hostname specifies the virtual hostname to match for protocol types that
define this concept. When unspecified, &ldquo;&rdquo;, or <code>*</code>, all hostnames are
matched. This field can be omitted for protocols that don&rsquo;t require
hostname based matching.</p>
<p>Hostname is the fully qualified domain name of a network host, as defined
by RFC 3986. Note the following deviations from the &ldquo;host&rdquo; part of the
URI as defined in the RFC:</p>
<ol>
<li>IP literals are not allowed.</li>
<li>The <code>:</code> delimiter is not respected because ports are not allowed.</li>
</ol>
<p>Hostname can be &ldquo;precise&rdquo; which is a domain name without the terminating
dot of a network host (e.g. &ldquo;foo.example.com&rdquo;) or &ldquo;wildcard&rdquo;, which is a
domain name prefixed with a single wildcard label (e.g. <code>*.example.com</code>).
The wildcard character <code>*</code> must appear by itself as the first DNS label
and matches only a single label.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<p>Port is the network port. Multiple listeners may use the
same port, subject to the Listener compatibility rules.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>protocol</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.ProtocolType">
ProtocolType
</a>
</em>
</td>
<td>
<p>Protocol specifies the network protocol this listener expects to receive.
The GatewayClass MUST apply the Hostname match appropriately for each
protocol:</p>
<ul>
<li>For the &ldquo;TLS&rdquo; protocol, the Hostname match MUST be
applied to the <a href="https://tools.ietf.org/html/rfc6066#section-3">SNI</a>
server name offered by the client.</li>
<li>For the &ldquo;HTTP&rdquo; protocol, the Hostname match MUST be
applied to the host portion of the
<a href="https://tools.ietf.org/html/rfc7230#section-5.5">effective request URI</a>
or the <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.3">:authority pseudo-header</a></li>
<li>For the &ldquo;HTTPS&rdquo; protocol, the Hostname match MUST be
applied at both the TLS and HTTP protocol layers.</li>
</ul>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayTLSConfig">
GatewayTLSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS is the TLS configuration for the Listener. This field
is required if the Protocol field is &ldquo;HTTPS&rdquo; or &ldquo;TLS&rdquo; and
ignored otherwise.</p>
<p>The association of SNIs to Certificate defined in GatewayTLSConfig is
defined based on the Hostname field for this listener.</p>
<p>The GatewayClass MUST use the longest matching SNI out of all
available certificates for any TLS handshake.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>routes</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteBindingSelector">
RouteBindingSelector
</a>
</em>
</td>
<td>
<p>Routes specifies a schema for associating routes with the
Listener using selectors. A Route is a resource capable of
servicing a request and allows a cluster operator to expose
a cluster resource (i.e. Service) by externally-reachable
URL, load-balance traffic and terminate SSL/TLS.  Typically,
a route is a &ldquo;HTTPRoute&rdquo; or &ldquo;TCPRoute&rdquo; in group
&ldquo;networking.x-k8s.io&rdquo;, however, an implementation may support
other types of resources.</p>
<p>The Routes selector MUST select a set of objects that
are compatible with the application protocol specified in
the Protocol field.</p>
<p>Although a client request may technically match multiple route rules,
only one rule may ultimately receive the request. Matching precedence
MUST be determined in order of the following criteria:</p>
<ul>
<li>The most specific match. For example, the most specific HTTPRoute match
is determined by the longest matching combination of hostname and path.</li>
<li>The oldest Route based on creation timestamp. For example, a Route with
a creation timestamp of &ldquo;2020-09-08 01:02:03&rdquo; is given precedence over
a Route with a creation timestamp of &ldquo;2020-09-08 01:02:04&rdquo;.</li>
<li>If everything else is equivalent, the Route appearing first in
alphabetical order (namespace/name) should be given precedence. For
example, foo/bar is given precedence over foo/baz.</li>
</ul>
<p>All valid portions of a Route selected by this field should be supported.
Invalid portions of a Route can be ignored (sometimes that will mean the
full Route). If a portion of a Route transitions from valid to invalid,
support for that portion of the Route should be dropped to ensure
consistency. For example, even if a filter specified by a Route is
invalid, the rest of the Route should still be supported.</p>
<p>Support: Core</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.ListenerConditionReason">ListenerConditionReason
(<code>string</code> alias)</p></h3>
<p>
<p>ListenerConditionReason defines the set of reasons that explain
why a particular Listener condition type has been raised.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;DegradedRoutes&#34;</p></td>
<td><p>This reason is used with the &ldquo;ResolvedRefs&rdquo; condition
when not all of the routes selected by this Listener could be
configured. The specific reason for the degraded route should
be indicated in the route&rsquo;s .Status.Conditions field.</p>
</td>
</tr><tr><td><p>&#34;HostnameConflict&#34;</p></td>
<td><p>This reason is used with the &ldquo;Conflicted&rdquo; condition when
the Listener conflicts with hostnames in other Listeners. For
example, this reason would be used when multiple Listeners on
the same port use <code>*</code> in the hostname field.</p>
</td>
</tr><tr><td><p>&#34;Invalid&#34;</p></td>
<td><p>This reason is used with the &ldquo;Ready&rdquo; condition when the
Listener is syntactically or semantically invalid.</p>
</td>
</tr><tr><td><p>&#34;InvalidCertificateRef&#34;</p></td>
<td><p>This reason is used with the &ldquo;ResolvedRefs&rdquo; condition when the
Listener has a TLS configuration with a TLS CertificateRef
that is invalid or cannot be resolved.</p>
</td>
</tr><tr><td><p>&#34;InvalidRoutesRef&#34;</p></td>
<td><p>This reason is used with the &ldquo;ResolvedRefs&rdquo; condition when
the Listener&rsquo;s Routes selector or kind is invalid or cannot
be resolved. Note that it is not an error for this selector to
not resolve any Routes, and the &ldquo;ResolvedRefs&rdquo; status condition
should not be raised in that case.</p>
</td>
</tr><tr><td><p>&#34;Pending&#34;</p></td>
<td><p>This reason is used with the &ldquo;Ready&rdquo; condition when the
Listener is not yet not online and ready to accept client
traffic.</p>
</td>
</tr><tr><td><p>&#34;PortUnavailable&#34;</p></td>
<td><p>This reason is used with the &ldquo;Detached&rdquo; condition when the
Listener requests a port that cannot be used on the Gateway.</p>
</td>
</tr><tr><td><p>&#34;ProtocolConflict&#34;</p></td>
<td><p>This reason is used with the &ldquo;Conflicted&rdquo; condition when
multiple Listeners are specified with the same Listener port
number, but have conflicting protocol specifications.</p>
</td>
</tr><tr><td><p>&#34;RouteConflict&#34;</p></td>
<td><p>This reason is used with the &ldquo;Conflicted&rdquo; condition when the route
resources selected for this Listener conflict with other
specified properties of the Listener (e.g. Protocol).
For example, a Listener that specifies &ldquo;UDP&rdquo; as the protocol
but a route selector that resolves &ldquo;TCPRoute&rdquo; objects.</p>
</td>
</tr><tr><td><p>&#34;UnsupportedAddress&#34;</p></td>
<td><p>This reason is used with the &ldquo;Detached&rdquo; condition when
the Listener could not be attached to the Gateway because the
requested address is not supported.</p>
</td>
</tr><tr><td><p>&#34;UnsupportedExtension&#34;</p></td>
<td><p>This reason is used with the &ldquo;Detached&rdquo; condition when the
controller detects that an implementation-specific Listener
extension is being requested, but is not able to support
the extension.</p>
</td>
</tr><tr><td><p>&#34;UnsupportedProtocol&#34;</p></td>
<td><p>This reason is used with the &ldquo;Detached&rdquo; condition when the
Listener could not be attached to be Gateway because its
protocol type is not supported.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.ListenerConditionType">ListenerConditionType
(<code>string</code> alias)</p></h3>
<p>
<p>ListenerConditionType is a type of condition associated with the
listener. This type should be used with the ListenerStatus.Conditions
field.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;Conflicted&#34;</p></td>
<td><p>This condition indicates that the controller was unable to resolve
conflicting specification requirements for this Listener. If a
Listener is conflicted, its network port should not be configured
on any network elements.</p>
<p>Possible reasons for this condition to be true are:</p>
<ul>
<li>&ldquo;HostnameConflict&rdquo;</li>
<li>&ldquo;ProtocolConflict&rdquo;</li>
<li>&ldquo;RouteConflict&rdquo;</li>
</ul>
<p>Controllers may raise this condition with other reasons,
but should prefer to use the reasons listed above to improve
interoperability.</p>
</td>
</tr><tr><td><p>&#34;Detached&#34;</p></td>
<td><p>This condition indicates that, even though the listener is
syntactically and semantically valid, the controller is not able
to configure it on the underlying Gateway infrastructure.</p>
<p>A Listener is specified as a logical requirement, but needs to be
configured on a network endpoint (i.e. address and port) by a
controller. The controller may be unable to attach the Listener
if it specifies an unsupported requirement, or prerequisite
resources are not available.</p>
<p>Possible reasons for this condition to be true are:</p>
<ul>
<li>&ldquo;PortUnavailable&rdquo;</li>
<li>&ldquo;UnsupportedExtension&rdquo;</li>
<li>&ldquo;UnsupportedProtocol&rdquo;</li>
<li>&ldquo;UnsupportedAddress&rdquo;</li>
</ul>
<p>Controllers may raise this condition with other reasons,
but should prefer to use the reasons listed above to improve
interoperability.</p>
</td>
</tr><tr><td><p>&#34;Ready&#34;</p></td>
<td><p>This condition indicates whether the Listener has been
configured on the Gateway.</p>
<p>Possible reasons for this condition to be false are:</p>
<ul>
<li>&ldquo;Invalid&rdquo;</li>
<li>&ldquo;Pending&rdquo;</li>
</ul>
<p>Controllers may raise this condition with other reasons,
but should prefer to use the reasons listed above to improve
interoperability.</p>
</td>
</tr><tr><td><p>&#34;ResolvedRefs&#34;</p></td>
<td><p>This condition indicates whether the controller was able to
resolve all the object references for the Listener.</p>
<p>Possible reasons for this condition to be false are:</p>
<ul>
<li>&ldquo;DegradedRoutes&rdquo;</li>
<li>&ldquo;InvalidCertificateRef&rdquo;</li>
<li>&ldquo;InvalidRoutesRef&rdquo;</li>
</ul>
<p>Controllers may raise this condition with other reasons,
but should prefer to use the reasons listed above to improve
interoperability.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.ListenerStatus">ListenerStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayStatus">GatewayStatus</a>)
</p>
<p>
<p>ListenerStatus is the status associated with a Listener.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<p>Port is the unique Listener port value for which this message is
reporting the status.</p>
</td>
</tr>
<tr>
<td>
<code>protocol</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.ProtocolType">
ProtocolType
</a>
</em>
</td>
<td>
<p>Protocol is the Listener protocol value for which this message is
reporting the status.</p>
</td>
</tr>
<tr>
<td>
<code>hostname</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Hostname">
Hostname
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Hostname is the Listener hostname value for which this message is
reporting the status.</p>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#condition-v1-meta">
[]Kubernetes meta/v1.Condition
</a>
</em>
</td>
<td>
<p>Conditions describe the current condition of this listener.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.LocalObjectReference">LocalObjectReference
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendTLSConfig">BackendTLSConfig</a>, 
<a href="#networking.x-k8s.io/v1alpha1.GatewayTLSConfig">GatewayTLSConfig</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRequestMirrorFilter">HTTPRequestMirrorFilter</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">HTTPRouteFilter</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteForwardTo">HTTPRouteForwardTo</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteMatch">HTTPRouteMatch</a>, 
<a href="#networking.x-k8s.io/v1alpha1.RouteForwardTo">RouteForwardTo</a>, 
<a href="#networking.x-k8s.io/v1alpha1.RouteTLSConfig">RouteTLSConfig</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteMatch">TCPRouteMatch</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteMatch">TLSRouteMatch</a>, 
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteMatch">UDPRouteMatch</a>)
</p>
<p>
<p>LocalObjectReference identifies an API object within the namespace of the
referrer.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>group</code></br>
<em>
string
</em>
</td>
<td>
<p>Group is the group of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind is kind of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<p>Name is the name of the referent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.ParametersReference">ParametersReference
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClassSpec">GatewayClassSpec</a>)
</p>
<p>
<p>ParametersReference identifies an API object containing controller-specific
configuration resource within the cluster.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>group</code></br>
<em>
string
</em>
</td>
<td>
<p>Group is the group of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind is kind of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<p>Name is the name of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>scope</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Scope represents if the referent is a Cluster or Namespace scoped resource.
This may be set to &ldquo;Cluster&rdquo; or &ldquo;Namespace&rdquo;.</p>
</td>
</tr>
<tr>
<td>
<code>namespace</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Namespace is the namespace of the referent.
This field is required when scope is set to &ldquo;Namespace&rdquo; and ignored when
scope is set to &ldquo;Cluster&rdquo;.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.PathMatchType">PathMatchType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPPathMatch">HTTPPathMatch</a>)
</p>
<p>
<p>PathMatchType specifies the semantics of how HTTP paths should be compared.
Valid PathMatchType values are:</p>
<ul>
<li>&ldquo;Exact&rdquo;</li>
<li>&ldquo;Prefix&rdquo;</li>
<li>&ldquo;RegularExpression&rdquo;</li>
<li>&ldquo;ImplementationSpecific&rdquo;</li>
</ul>
<p>Prefix and Exact paths must be syntactically valid:</p>
<ul>
<li>Must begin with the &lsquo;/&rsquo; character</li>
<li>Must not contain consecutive &lsquo;/&rsquo; characters (e.g. /foo///, //).</li>
<li>For prefix paths, a trailing &lsquo;/&rsquo; character in the Path is ignored,
e.g. /abc and /abc/ specify the same match.</li>
</ul>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;Exact&#34;</p></td>
<td></td>
</tr><tr><td><p>&#34;ImplementationSpecific&#34;</p></td>
<td></td>
</tr><tr><td><p>&#34;Prefix&#34;</p></td>
<td></td>
</tr><tr><td><p>&#34;RegularExpression&#34;</p></td>
<td></td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.PortNumber">PortNumber
(<code>int32</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendRef">BackendRef</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRequestMirrorFilter">HTTPRequestMirrorFilter</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteForwardTo">HTTPRouteForwardTo</a>, 
<a href="#networking.x-k8s.io/v1alpha1.Listener">Listener</a>, 
<a href="#networking.x-k8s.io/v1alpha1.ListenerStatus">ListenerStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.RouteForwardTo">RouteForwardTo</a>)
</p>
<p>
<p>PortNumber defines a network port.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.ProtocolType">ProtocolType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.Listener">Listener</a>, 
<a href="#networking.x-k8s.io/v1alpha1.ListenerStatus">ListenerStatus</a>)
</p>
<p>
<p>ProtocolType defines the application protocol accepted by a Listener.
Implementations are not required to accept all the defined protocols.
If an implementation does not support a specified protocol, it
should raise a &ldquo;Detached&rdquo; condition for the affected Listener with
a reason of &ldquo;UnsupportedProtocol&rdquo;.</p>
<p>Core ProtocolType values are listed in the table below.</p>
<p>Implementations can define their own protocols if a core ProtocolType does not
exist. Such definitions must use prefixed name, such as
<code>mycompany.com/my-custom-protocol</code>. Un-prefixed names are reserved for core
protocols. Any protocol defined by implementations will fall under custom
conformance.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;HTTP&#34;</p></td>
<td><p>Accepts cleartext HTTP/1.1 sessions over TCP.</p>
</td>
</tr><tr><td><p>&#34;HTTPS&#34;</p></td>
<td><p>Accepts HTTP/1.1 or HTTP/2 sessions over TLS.</p>
</td>
</tr><tr><td><p>&#34;TCP&#34;</p></td>
<td><p>Accepts TCP sessions.</p>
</td>
</tr><tr><td><p>&#34;TLS&#34;</p></td>
<td><p>Accepts TLS sessions over TCP.</p>
</td>
</tr><tr><td><p>&#34;UDP&#34;</p></td>
<td><p>Accepts UDP packets.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteBindingSelector">RouteBindingSelector
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.Listener">Listener</a>)
</p>
<p>
<p>RouteBindingSelector defines a schema for associating routes with the Gateway.
If Namespaces and Selector are defined, only routes matching both selectors are
associated with the Gateway.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>namespaces</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteNamespaces">
RouteNamespaces
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Namespaces indicates in which namespaces Routes should be selected
for this Gateway. This is restricted to the namespace of this Gateway by
default.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>selector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Selector specifies a set of route labels used for selecting
routes to associate with the Gateway. If this Selector is defined,
only routes matching the Selector are associated with the Gateway.
An empty Selector matches all routes.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>group</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Group is the group of the route resource to select. Omitting the value or specifying
the empty string indicates the networking.x-k8s.io API group.
For example, use the following to select an HTTPRoute:</p>
<p>routes:
kind: HTTPRoute</p>
<p>Otherwise, if an alternative API group is desired, specify the desired
group:</p>
<p>routes:
group: acme.io
kind: FooRoute</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind is the kind of the route resource to select.</p>
<p>Kind MUST correspond to kinds of routes that are compatible with the
application protocol specified in the Listener&rsquo;s Protocol field.</p>
<p>If an implementation does not support or recognize this
resource type, it SHOULD set the &ldquo;ResolvedRefs&rdquo; condition to false for
this listener with the &ldquo;InvalidRoutesRef&rdquo; reason.</p>
<p>Support: Core</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteConditionType">RouteConditionType
(<code>string</code> alias)</p></h3>
<p>
<p>RouteConditionType is a type of condition for a route.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;Admitted&#34;</p></td>
<td><p>This condition indicates whether the route has been admitted
or rejected by a Gateway, and why.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteForwardTo">RouteForwardTo
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteRule">TCPRouteRule</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteRule">TLSRouteRule</a>, 
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteRule">UDPRouteRule</a>)
</p>
<p>
<p>RouteForwardTo defines how a Route should forward a request.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceName refers to the name of the Service to forward matched requests
to. When specified, this takes the place of BackendRef. If both
BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the rule is not included in the route.
The controller should raise the &ldquo;ResolvedRefs&rdquo; condition on the Gateway
with the &ldquo;DegradedRoutes&rdquo; reason. The gateway status for this route should
be updated with a condition that describes the error more specifically.</p>
<p>The protocol to use is defined using AppProtocol field (introduced in
Kubernetes 1.18) in the Service resource. In the absence of the
AppProtocol field a <code>networking.x-k8s.io/app-protocol</code> annotation on the
BackendPolicy resource may be used to define the protocol. If the
AppProtocol field is available, this annotation should not be used. The
AppProtocol field, when populated, takes precedence over the annotation
in the BackendPolicy resource. For custom backends, it is encouraged to
add a semantically-equivalent field in the Custom Resource Definition.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>backendRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>BackendRef is a reference to a backend to forward matched requests to. If
both BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the rule is not included in the route.
The controller should raise the &ldquo;ResolvedRefs&rdquo; condition on the Gateway
with the &ldquo;DegradedRoutes&rdquo; reason. The gateway status for this route should
be updated with a condition that describes the error more specifically.</p>
<p>Support: Custom</p>
</td>
</tr>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Port specifies the destination port number to use for the
backend referenced by the ServiceName or BackendRef field.
If unspecified, the destination port in the request is used
when forwarding to a backendRef or serviceName.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>weight</code></br>
<em>
int32
</em>
</td>
<td>
<em>(Optional)</em>
<p>Weight specifies the proportion of HTTP requests forwarded to the backend
referenced by the ServiceName or BackendRef field. This is computed as
weight/(sum of all weights in this ForwardTo list). For non-zero values,
there may be some epsilon from the exact proportion defined here
depending on the precision an implementation supports. Weight is not a
percentage and the sum of weights does not need to equal 100.</p>
<p>If only one backend is specified and it has a weight greater than 0, 100%
of the traffic is forwarded to that backend. If weight is set to 0, no
traffic should be forwarded for this entry. If unspecified, weight
defaults to 1.</p>
<p>Support: Extended</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteGatewayStatus">RouteGatewayStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.RouteStatus">RouteStatus</a>)
</p>
<p>
<p>RouteGatewayStatus describes the status of a route with respect to an
associated Gateway.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>gatewayRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayReference">
GatewayReference
</a>
</em>
</td>
<td>
<p>GatewayRef is a reference to a Gateway object that is associated with
the route.</p>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#condition-v1-meta">
[]Kubernetes meta/v1.Condition
</a>
</em>
</td>
<td>
<p>Conditions describes the status of the route with respect to the
Gateway. The &ldquo;Admitted&rdquo; condition must always be specified by controllers
to indicate whether the route has been admitted or rejected by the Gateway,
and why. Note that the route&rsquo;s availability is also subject to the Gateway&rsquo;s
own status conditions and listener status.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteGateways">RouteGateways
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteSpec">HTTPRouteSpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteSpec">TCPRouteSpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteSpec">TLSRouteSpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteSpec">UDPRouteSpec</a>)
</p>
<p>
<p>RouteGateways defines which Gateways will be able to use a route. If this
field results in preventing the selection of a Route by a Gateway, an
&ldquo;Admitted&rdquo; condition with a status of false must be set for the Gateway on
that Route.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>allow</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayAllowType">
GatewayAllowType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Allow indicates which Gateways will be allowed to use this route.
Possible values are:
* All: Gateways in any namespace can use this route.
* FromList: Only Gateways specified in GatewayRefs may use this route.
* SameNamespace: Only Gateways in the same namespace may use this route.</p>
</td>
</tr>
<tr>
<td>
<code>gatewayRefs</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayReference">
[]GatewayReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>GatewayRefs must be specified when Allow is set to &ldquo;FromList&rdquo;. In that
case, only Gateways referenced in this list will be allowed to use this
route. This field is ignored for other values of &ldquo;Allow&rdquo;.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteNamespaces">RouteNamespaces
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.RouteBindingSelector">RouteBindingSelector</a>)
</p>
<p>
<p>RouteNamespaces indicate which namespaces Routes should be selected from.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>from</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteSelectType">
RouteSelectType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>From indicates where Routes will be selected for this Gateway. Possible
values are:
* All: Routes in all namespaces may be used by this Gateway.
* Selector: Routes in namespaces selected by the selector may be used by
this Gateway.
* Same: Only Routes in the same namespace may be used by this Gateway.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>selector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Selector must be specified when From is set to &ldquo;Selector&rdquo;. In that case,
only Routes in Namespaces matching this Selector will be selected by this
Gateway. This field is ignored for other values of &ldquo;From&rdquo;.</p>
<p>Support: Core</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteSelectType">RouteSelectType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.RouteNamespaces">RouteNamespaces</a>)
</p>
<p>
<p>RouteSelectType specifies where Routes should be selected by a Gateway.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;All&#34;</p></td>
<td><p>Routes in all namespaces may be used by this Gateway.</p>
</td>
</tr><tr><td><p>&#34;Same&#34;</p></td>
<td><p>Only Routes in the same namespace as the Gateway may be used by this Gateway.</p>
</td>
</tr><tr><td><p>&#34;Selector&#34;</p></td>
<td><p>Only Routes in namespaces selected by the selector may be used by this Gateway.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteStatus">RouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteStatus">HTTPRouteStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteStatus">TCPRouteStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteStatus">TLSRouteStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteStatus">UDPRouteStatus</a>)
</p>
<p>
<p>RouteStatus defines the observed state that is required across
all route types.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGatewayStatus">
[]RouteGatewayStatus
</a>
</em>
</td>
<td>
<p>Gateways is a list of Gateways that are associated with the route,
and the status of the route with respect to each Gateway. When a
Gateway selects this route, the controller that manages the Gateway
must add an entry to this list when the controller first sees the
route and should update the entry as appropriate when the route is
modified.</p>
<p>A maximum of 100 Gateways will be represented in this list. If this list
is full, there may be additional Gateways using this Route that are not
included in the list. An empty list means the route has not been admitted
by any Gateway.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteTLSConfig">RouteTLSConfig
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteSpec">HTTPRouteSpec</a>)
</p>
<p>
<p>RouteTLSConfig describes a TLS configuration defined at the Route level.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>certificateRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<p>CertificateRef refers to a Kubernetes object that
contains a TLS certificate and private key.
This certificate MUST be used for TLS handshakes for the domain
this RouteTLSConfig is associated with.
If an entry in this list omits or specifies the empty
string for both the group and kind, the resource defaults to &ldquo;secrets&rdquo;.
An implementation may support other resources (for example, resource
&ldquo;mycertificates&rdquo; in group &ldquo;networking.acme.io&rdquo;).</p>
<p>Support: Core (Kubernetes Secrets)</p>
<p>Support: Implementation-specific (Other resource types)</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TCPRouteMatch">TCPRouteMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteRule">TCPRouteRule</a>)
</p>
<p>
<p>TCPRouteMatch defines the predicate used to match connections to a
given action.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>extensionRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ExtensionRef is an optional, implementation-specific extension to the
&ldquo;match&rdquo; behavior.  For example, resource &ldquo;mytcproutematcher&rdquo; in group
&ldquo;networking.acme.io&rdquo;. If the referent cannot be found, the rule is not
included in the route. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DegradedRoutes&rdquo; reason. The gateway
status for this route should be updated with a condition that describes
the error more specifically.</p>
<p>Support: Custom</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TCPRouteRule">TCPRouteRule
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteSpec">TCPRouteSpec</a>)
</p>
<p>
<p>TCPRouteRule is the configuration for a given rule.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>matches</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteMatch">
[]TCPRouteMatch
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Matches define conditions used for matching the rule against
incoming TCP connections. Each match is independent, i.e. this
rule will be matched if <strong>any</strong> one of the matches is satisfied.
If unspecified, all requests from the associated gateway TCP
listener will match.</p>
</td>
</tr>
<tr>
<td>
<code>forwardTo</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteForwardTo">
[]RouteForwardTo
</a>
</em>
</td>
<td>
<p>ForwardTo defines the backend(s) where matching requests should
be sent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TCPRouteSpec">TCPRouteSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRoute">TCPRoute</a>)
</p>
<p>
<p>TCPRouteSpec defines the desired state of TCPRoute</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteRule">
[]TCPRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of TCP matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TCPRouteStatus">TCPRouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRoute">TCPRoute</a>)
</p>
<p>
<p>TCPRouteStatus defines the observed state of TCPRoute</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>RouteStatus</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSModeType">TLSModeType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayTLSConfig">GatewayTLSConfig</a>)
</p>
<p>
<p>TLSModeType type defines how a Gateway handles TLS sessions.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;Passthrough&#34;</p></td>
<td><p>In this mode, the TLS session is NOT terminated by the Gateway. This
implies that the Gateway can&rsquo;t decipher the TLS stream except for
the ClientHello message of the TLS protocol.</p>
</td>
</tr><tr><td><p>&#34;Terminate&#34;</p></td>
<td><p>In this mode, TLS session between the downstream client
and the Gateway is terminated at the Gateway.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSOverridePolicy">TLSOverridePolicy
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayTLSConfig">GatewayTLSConfig</a>)
</p>
<p>
<p>TLSOverridePolicy defines a schema for overriding TLS settings at the Route
level.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>certificate</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteOverrideType">
TLSRouteOverrideType
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Certificate dictates if TLS certificates can be configured
via Routes. If set to &lsquo;Allow&rsquo;, a TLS certificate for a hostname
defined in a Route takes precedence over the certificate defined in
Gateway.</p>
<p>Support: Core</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRouteMatch">TLSRouteMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteRule">TLSRouteRule</a>)
</p>
<p>
<p>TLSRouteMatch defines the predicate used to match connections to a
given action.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>snis</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Hostname">
[]Hostname
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>SNIs defines a set of SNI names that should match against the
SNI attribute of TLS ClientHello message in TLS handshake.</p>
<p>SNI can be &ldquo;precise&rdquo; which is a domain name without the terminating
dot of a network host (e.g. &ldquo;foo.example.com&rdquo;) or &ldquo;wildcard&rdquo;, which is
a domain name prefixed with a single wildcard label (e.g. <code>*.example.com</code>).
The wildcard character <code>*</code> must appear by itself as the first DNS label
and matches only a single label. You cannot have a wildcard label by
itself (e.g. Host == <code>*</code>).</p>
<p>Requests will be matched against the Host field in the following order:</p>
<ol>
<li>If SNI is precise, the request matches this rule if the SNI in
ClientHello is equal to one of the defined SNIs.</li>
<li>If SNI is a wildcard, then the request matches this rule if the
SNI is to equal to the suffix (removing the first label) of the
wildcard rule.</li>
<li>If SNIs is unspecified, all requests associated with the gateway TLS
listener will match. This can be used to define a default backend
for a TLS listener.</li>
</ol>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>extensionRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ExtensionRef is an optional, implementation-specific extension to the
&ldquo;match&rdquo; behavior.  For example, resource &ldquo;mytlsroutematcher&rdquo; in group
&ldquo;networking.acme.io&rdquo;. If the referent cannot be found, the rule is not
included in the route. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DegradedRoutes&rdquo; reason. The gateway
status for this route should be updated with a condition that describes
the error more specifically.</p>
<p>Support: Custom</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRouteOverrideType">TLSRouteOverrideType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TLSOverridePolicy">TLSOverridePolicy</a>)
</p>
<p>
<p>TLSRouteOverrideType type defines the level of allowance for Routes
to override a specific TLS setting.</p>
</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr><td><p>&#34;Allow&#34;</p></td>
<td><p>Allows the parameter to be configured from all routes.</p>
</td>
</tr><tr><td><p>&#34;Deny&#34;</p></td>
<td><p>Prohibits the parameter from being configured from any route.</p>
</td>
</tr></tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRouteRule">TLSRouteRule
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteSpec">TLSRouteSpec</a>)
</p>
<p>
<p>TLSRouteRule is the configuration for a given rule.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>matches</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteMatch">
[]TLSRouteMatch
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Matches define conditions used for matching the rule against an
incoming TLS handshake. Each match is independent, i.e. this
rule will be matched if <strong>any</strong> one of the matches is satisfied.
If unspecified, all requests from the associated gateway TLS
listener will match.</p>
</td>
</tr>
<tr>
<td>
<code>forwardTo</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteForwardTo">
[]RouteForwardTo
</a>
</em>
</td>
<td>
<p>ForwardTo defines the backend(s) where matching requests should be
sent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRouteSpec">TLSRouteSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRoute">TLSRoute</a>)
</p>
<p>
<p>TLSRouteSpec defines the desired state of a TLSRoute resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteRule">
[]TLSRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of TLS matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRouteStatus">TLSRouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRoute">TLSRoute</a>)
</p>
<p>
<p>TLSRouteStatus defines the observed state of TLSRoute</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>RouteStatus</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.UDPRouteMatch">UDPRouteMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteRule">UDPRouteRule</a>)
</p>
<p>
<p>UDPRouteMatch defines the predicate used to match packets to a
given action.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>extensionRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ExtensionRef is an optional, implementation-specific extension to the
&ldquo;match&rdquo; behavior.  For example, resource &ldquo;myudproutematcher&rdquo; in group
&ldquo;networking.acme.io&rdquo;. If the referent cannot be found, the rule is not
included in the route. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DegradedRoutes&rdquo; reason. The gateway
status for this route should be updated with a condition that describes
the error more specifically.</p>
<p>Support: Custom</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.UDPRouteRule">UDPRouteRule
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteSpec">UDPRouteSpec</a>)
</p>
<p>
<p>UDPRouteRule is the configuration for a given rule.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>matches</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteMatch">
[]UDPRouteMatch
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Matches define conditions used for matching the rule against
incoming UDP connections. Each match is independent, i.e. this
rule will be matched if <strong>any</strong> one of the matches is satisfied.
If unspecified, all requests from the associated gateway UDP
listener will match.</p>
</td>
</tr>
<tr>
<td>
<code>forwardTo</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteForwardTo">
[]RouteForwardTo
</a>
</em>
</td>
<td>
<p>ForwardTo defines the backend(s) where matching requests should
be sent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.UDPRouteSpec">UDPRouteSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRoute">UDPRoute</a>)
</p>
<p>
<p>UDPRouteSpec defines the desired state of UDPRoute.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteRule">
[]UDPRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of UDP matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.UDPRouteStatus">UDPRouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRoute">UDPRoute</a>)
</p>
<p>
<p>UDPRouteStatus defines the observed state of UDPRoute.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>RouteStatus</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<p><em>
Generated with <code>gen-crd-api-reference-docs</code>.
</em></p>
