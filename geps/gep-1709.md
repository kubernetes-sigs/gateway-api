# GEP-1709: Conformance Profiles

* Issue: [#1709](https://github.com/kubernetes-sigs/gateway-api/issues/1709)
* Status: Provisional

## TLDR

Add selectable profiles for conformance tests which implementations can
subscribe to. Also add the ability to report conformance results back to the
Gateway API project and receive recognition. Conformance test reports will
add conformance data to the implementations page for the reporter which can
be linked to with badges from projects and repositories.

## Goals

- Add high level profiles which downstream implementations can subscribe to in
  order to run tests for the associated supported feature sets.
- Add a reporting mechanism where conformance results can be reported back to
  the Gateway API project and provide "badges" to visibly decorate the
  implementations as conformant according to their profiles.
- Expand conformance testing documentation significantly so that it becomes the
  "landing zone" for new prospective implementations and provides a clear and
  iterative process for how to get started implementing Gateway API support.

## Non-Goals

- We want to avoid adding any infrastructure for the reporting mechanism if
  feasible.
- For this iteration we don't want to add configuration files for conformance
  tests, instead leaving that to future iterations and working on the raw
  machinery here (see [alternatives considered](#alternatives-considered)).
- For this iteration we don't want to add container images for conformance test
  runs, instead leaving that to future iterations (see
  [alternatives considered](#alternatives-considered).

## Introduction

Since our conformance test suite was conceived of it's been our desire to
provide simple high level profiles that downstream implementations can
subscribe to. Today there's a little bit of this available in the way of
`SupportedFeatures` which can be subscribed to when running the tests, but the
purpose of this GEP is to take that a step further (and a level higher) and
create subscribable named profiles which indicate a "level of conformance"
which implementations can prove they satisfy and be recognized for.

## API

The API for conformance profiles will be a pipeline that implementations can
opt into. The workflow is effectively:

1. select a [profile](#profiles)
2. [integrate](#integration) tests in the downstream project
3. [report results and get certified](#certification)

The goal is to make selecting a conformance profile as simple of a process as
feasible and support both the existing command line integration approach (e.g. `go test`) as well
as a [Golang][go] approach using the conformance suite as a library.

[go]:https://go.dev

### Profiles

Initially there will be three profiles:

- `Layer4`
- `Layer7`
- `Mesh`

> **NOTE**: these are simply the initial profiles we're going to start with,
> it's plausible for there to be more in the future.

These named profiles are effectively categories which represent the high level
grouping of tests. When conformance is reported using one of these profiles
extra features can be covered according to support levels:

- `extended`
- `implementation-specific`

> **NOTE**: `implementation-specific` doesn't really have much in the way of
> tests today, but it is something users want to be able to display so it's
> considered for reporting purposes.

The technical implementation of these profiles is very simple: effectively a
"profile" is a static compilation of existing [SupportedFeatures][feat] which
represent the named category. Features that aren't covered under a "core" level
of support are opt-in.

[feat]:https://github.com/kubernetes-sigs/gateway-api/blob/c61097edaa3b1fad29721e787fee4b02c35e3103/conformance/utils/suite/suite.go#L33

### Integration

Integrating the test suite into your implementation can be done using one of
the following methods:

- The [go test][go-test] command line interface which enables projects of any
  language to run the test suite on any platform [Golang][go] supports.
- Using the conformance test suite as a [Golang library][lib] within an already
  existing test suite.

> **NOTE**: Usage as a library is already an established colloquialism in the
> community, this effort simply intends to make that more official.

Conformance profiles are passed as arguments when running the test suite. For
instance when running via command line:

```console
$ go test ./conformance/... -args -gateway-class=acme -conformance-profile=Layer7
```

Or the equivalent configuration using the Golang library:

```go
cSuite, err := suite.New(suite.Options{
    GatewayClassName: "acme",
    Profiles: sets.New(Layer7),
    // other options
})
require.NoError(t, err, "misconfigured conformance test suite")
cSuite.Setup(t)

for i := 0; i < len(tests.ConformanceTests); i++ {
    test := tests.ConformanceTests[i]
    test.Run(t, cSuite)
}
```

> **NOTE**: In the `suite.Options` above it's still possible to add `SkipTests`
> but when used in conjunction with `Profile` this will result in a report that
> the profile is not valid for reporting. Implementations in this state may be
> able to report themselves as "in progress", see the
> [certification section](#certification) for details.

Alternatively for an `Extended` conformance profile where not all of the
features are implemented (as described in the [profiles](#profiles) section
above):

```console
$ go test ./conformance/... -args \
    -gateway-class=acme \
    -conformance-profiles=Layer7,Layer4 \
    -unsupported-features=HTTPResponseHeaderModification,HTTPRouteMethodMatching,HTTPRouteQueryParamMatching,
```

Or the equivalent configuration using the Golang library:

```go
cSuite, err := suite.New(suite.Options{
    GatewayClassName: "acme",
    Profiles: sets.New(
        Layer7,
        Layer4,
    ),
    UnsupportedFeatures: sets.New(
        suite.SupportHTTPResponseHeaderModification,
        suite.SupportHTTPRouteMethodMatching,
        suite.SupportHTTPRouteQueryParamMatching,
    ),
    // other options
})
require.NoError(t, err, "misconfigured conformance test suite")
cSuite.Setup(t)

for i := 0; i < len(tests.ConformanceTests); i++ {
    test := tests.ConformanceTests[i]
    test.Run(t, cSuite)
}
```

> **NOTE**: `UnsupportedFeatures` must match support levels. Disabling features
> which are in core will emit a warning and wont be reportable.

> **NOTE**: In the future we may consider expanding the options to configure
> and run the conformance test suite using a container image and/or via a
> configuration file, however it was decided to hold off from doing any of
> those in this iteration to avoid it getting to big (see the
> [alternatives](#alternatives-considered) section for more thoughts).

Some implementations may support more or less extended features than others,
so in some cases it could be cumbersome to have to list ALL features that you
_don't_ support so we optionally and inversely allow `SupportedFeatures` so
you can pick which option makes sense to you, and under the hood the
expressions will compile to the same overall list:

```go
cSuite, err := suite.New(suite.Options{
    GatewayClassName: "acme",
    Profiles: sets.New(
        Layer7,
        Layer4,
    ),
    SupportedFeatures: sets.New(
        suite.SupportHTTPRouteMethodMatching,
    ),
    // other options
})
```

> **NOTE**: The `UnsupportedFeatures` and `SupportedFeatures` fields are 
> mutually exclusive.

Once an implementation has integrated with the conformance test suite, they can
move on to [certification](#certification) to report the results.

[go-test]:https://go.dev/doc/tutorial/add-a-test
[go]:https://go.dev
[lib]:https://pkg.go.dev/sigs.k8s.io/gateway-api@v0.6.1/conformance/utils/suite

### Certification

Implementations will be able to report their conformance testing results using
our [reporting process](#reporting-process). Implementations will be able to
visibly demonstrate their conformance results on their downstream projects and
repositories using our [certification process](#certification-process).

#### Reporting Process

When conformance tests complete a log message will be emitted:

```console
Success! Conformance profiles "Layer7" and "Layer4" passed for version v0.7.0.
The following extended features were flagged as not supported for "Layer7Extended":
- HTTPResponseHeaderModification
- HTTPRouteQueryParamMatching
```

For the above output upstream Gateway API can manually generate or update a report
in the following format:

```json
apiVersion: v1alpha1
kind: ConformanceReport
implementation: acmeorg-acme
reports:
  layer4:
    releases:
    - tag: v0.7.0
    - tag: v0.6.2
    - tag: v0.6.1
  layer7:
    releases:
    - tag: v0.7.0
      extended:
        unsupportedFeatures:
        - HTTPResponseHeaderModification
        - HTTPRouteQueryParamMatching
    - tag: v0.6.2
      extended:
        unsupportedFeatures:
        - HTTPResponseHeaderModification
        - HTTPRouteQueryParamMatching
        - HTTPRouteMethodMatching
    - tag: v0.6.1
      extended:
        unsupportedFeatures:
        - HTTPResponseHeaderModification
        - HTTPRouteQueryParamMatching
        - HTTPRouteMethodMatching
maintainers:
- @kubernetes-sigs/gateway-api-maintainers
```

> **NOTE**: In the above the `implementation` field is a combination of
> `<organization>-<project>`. Organizations can be an open source organization,
> an individual, a company, e.t.c.. Organizations can theoretically have more
> than one `<project>` name and submit separate reports for each of them.

> **NOTE**: The above demonstrates that the `acmeorg-acme` project was already
> passing for versions prior to `v0.7.0`. This is how we will track history of
> conformance for releases across implementations, but at some point might
> require some archival process (which we probably don't have to worry about
> for this iteration). You can also see that there's been progress to add the
> `HTTPRouteMethodMatching` for the latest release.

> **NOTE**: The `maintainers` field indicates the Github usernames or team
> names of those who are responsible for maintaining this file, so they can be
> easily contacted when needed (e.g. for relevant release announcements
> regarding conformance, e.t.c.).

The implementation can compile its `ConformanceReport` and upload it to the
Gateway API project by creating a pull request. The file should be uploaded
to the following sub-directory:

```console
conformance/results/<organization>-<project>.yaml
```

> **NOTE**: For this iteration we're focusing on getting these reports created
> but at first they will probably be created by hand. In future iterations and
> after having some time to experience the system, tooling to handle reporting
> must be created.

This will start the certification process which will result in the
implementation receiving a badge they can use on their project pages and/or
repositories which indicates their conformance levels and link to their
conformance reports in the upstream Gateway API website.

> **NOTE**: No verification process (to prevent intentionally incorrect
> conformance results) will be implemented at this time. We expect that this wont
> be an issue in our community and even if someone were to try and "cheat" on
> the reporting the reputation loss for being caught would make them look very
> bad and would not be worth it.

#### Certification Process

For this initial iteration the raw report data of the `ConformanceReports` will
live in its own directory and _is predominantly meant for machine consumption_.
Report data will be compiled into human-friendly displays which will be added as
headers in the [implementations page][impl] and badges which link to these
displays. We will refer to this process as certification.

Certification starts with the pull request described during the [reporting
process](#reporting-process). Once the `ConformanceReport` is created or
updated a display layer in the implementations page will need to be updated to
point to the new data.

TODO: not sure exactly what the display will look like yet. We will need to
      sort this out before we consider this `implementable`.

CI will provide [badges][bdg] to contributors at the end of the process which
link to the implementations page for that specific implementation and can be
easily added via markdown to Git repositories.

[impl]:https://gateway-api.sigs.k8s.io/implementations/
[bdg]:https://shields.io

## Alternatives Considered

### Conformance Test Configuration File

Conformance testing is currently done mainly through command line with
`go test` or via use of the conformance test suite as a library in Golang
projects. We considered whether adding the alternative to provide a
configuration file to the test suite would be nice, but we haven't heard
any specific demand for that from implementors yet so we're leaving the
idea here for later iterations to consider.

### Conformance Test Container Image

Providing a container image which could be fed deployment instructions for an
implementation was considered while working on this GET but it seemed like a
scope all unto itself so we're avoiding it here and perhaps a later iteration
could take a look at that if there are asks in the community.

## References

- https://github.com/kubernetes-sigs/gateway-api/issues/1709
- https://github.com/kubernetes-sigs/gateway-api/issues/1329

