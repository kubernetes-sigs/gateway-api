# GEP-1911: Backend Protocol Selection

* Issue: [#1911](https://github.com/kubernetes-sigs/gateway-api/issues/1911)
* Status: Provisional

(See status definitions [here](overview.md#status).)

## TLDR

Not all implementations support automatic protocol selection. Even in some cases protocols are disabled without an explicit opt-in (eg. websockets with Contour & NGINX). Thus application developers need the ability to specify the protocol(s) that their application supports.

## Goals

- Support protocols that can have a Gateway `*Route` resource as a frontend
- Standardize Gateway API implementations on the protocols & constants defined by the Kubernetes [Standard Application Protocols (KEP-3726)](https://github.com/kubernetes/enhancements/tree/master/keps/sig-network/3726-standard-application-protocols#summary)
- Support backends with multiple protocols on the same port (ie. h2c/http1)

## Non-Goals

- Backend TLS (covered in [GEP-1897](https://github.com/kubernetes-sigs/gateway-api/issues/1897))
- Additional protocol specific configuration
- Disabling Protocols

## Introduction

Since Kubernetes 1.20 the `core/v1.Service` and `core/v1.EndpointSlice` object has a stable `appProtocol` field. It's purpose is to allow end-users to specify an application protocol (L7) for each service port.

Originally the use of this field in the Gateway API was rejected in [GEP-1282](geps/gep-1282.md#non-goals):
> v1.Serviceâ€™s appProtocol field is not fit for purpose, because it is defined as accepting values either from the IANA Service Name registry, or domain-prefixed values and we need more flexibility than that. 

Since then a Kubernetes enhancement proposal was created [KEP-3726](https://github.com/kubernetes/enhancements/issues/3726) to repurpose `appProtocol` to include a convention for protocols that are not IANA service names. This would involve prefixing protocol names with `kubernetes.io/*`. 

Note: Kubernetes will automatically create `EndpointSlices` for `Services` that have a selector. [Custom `EndpointSlices`](https://kubernetes.io/docs/concepts/services-networking/service/#custom-endpointslices) can manually be created.

## API Semantics

A Gateway implementation MUST recognize the Kubernetes Standard Application Protocols ([KEP-3726](https://github.com/kubernetes/enhancements/tree/master/keps/sig-network/3726-standard-application-protocols)) for specifying the protocol for a backend reference in a Gateway API `*Route` resource

Thus when a `*Route` points to a Kubernetes Service resource the backend protocol for each port can be specified by
- setting the `appProtocol` field on the Kubernetes `Service`
- setting the `appProtocol` field on an `Endpoint`/`EndpointSlice` object associated with a Kubernetes `Service`

At the moment there exists two defined constants:
- `kubernetes.io/h2c` - HTTP/2 over cleartext as described in https://www.rfc-editor.org/rfc/rfc7540
- `kubernetes.io/raw` - Instructs the implementation to look at the `Service`'s `protocol` field which supports `TCP`, `UDP`, and `SCTP`. Default is `TCP`.

### Multiple Protocols on the same port

Only the Kubernetes `Service` `protocol` field supports multiple protocols on the same port. See the details in [KEP-1435](https://github.com/kubernetes/enhancements/tree/master/keps/sig-network/1435-mixed-protocol-lb).

Implementations MUST recognize support for multiple protocols on the same port.

Currently Kubernetes `Service` API does not allow different `appProtocol` values for the same port. At this time there seems to be interest in changing `appProtocol` to be a list in order to faciliate this use-case.

### Default Protocols

If a backend protocol isn't specified an implementation MAY infer the backend protocol through its own means. 

### Unsupported/Incompatible Protocols

If a Route attached to a Gateway is not able to sending traffic to the backend using the specified protocol then it must set it's RouteConditionType `Accepted` to `False`, with a RouteConditionReason `UnsupportedProtocol`

### Supporting new protocols

To add support for a new protocol it should first become a Kubernetes Standard Application Protocol by updating the [KEP-3726](https://github.com/kubernetes/enhancements/tree/master/keps/sig-network/3726-standard-application-protocols). If the suggested protocol is not suited to have a `kubernetes.io/*` prefix then the Gateway API MAY support the new protocol using it's own prefix `gateway-api.kubernetes.io/*`.  Please make a PR to this GEP.

## Alternatives

### Single Meta-resource 

The first pass of this GEP proposed a new meta-resource [GEP-713](geps/gep-713.md) called `BackendProtocol`.

This allows end-users to specify a list of ports and a list of corresponding protocols that that single
port supports.

This was dropped in favour of supporting Kubernetes Standard Application Protocols. The Go and YAML API are
presented below for posterity.

#### Go API

```go
type BackendProtocol struct {
  // Standard type metadata
  metav1.TypeMeta `json:",inline"`

  // Standard object's metadata
  metav1.ObjectMeta `json:"metadata,omitempty"`

  // Spec defines the behaviour of this meta-resource
  Spec BackendProtocolSpec `json:"spec,omitempty"`
}

type BackendProtocolSpec struct {
  // Specifies the API resource who's protocols are being
  // explicitly defined
  TargetRef LocalObjectReference `json:"targetRef"`

  // Ports contains a list of protocols for a specific ports
  // When multiple protocols reference the same port the 
  // entries earlier in the list should have higher priority
  //
  // ie. attempt to use h2c otherwise fallback on http1
  //  ports: 
  //   - port: 80
  //     http2: 
  //       encrypted: false # enable h2c
  //   - port: 80
  //     http1: {}          # We also listen to http1 on port 80
  //
  Ports []BackendPort `json:"ports,omitempty"`
}

type BackendPort struct {
  // Number or name of the port who's protocol is being defined
  Port intstr.IntOrString

  PortProtocol `json:",inline"`
}

type PortProtocol struct {
  HTTP2     *HTTP2PortProtocol    `json:"http2"`
  HTTP1     *HTTP1PortProtocol    `json:"http1"`
  GRPC      *GRPCPortProtocol     `json:"grpc"`
  WebSocket *WebsocketPortProtocol`json:"websocket"`
}

type HTTP2PortProtocol struct {
  Cleartext bool // h2c when set to true

  // Future knobs can go here
}

type HTTPPortProtocol struct {
  // Future knobs can go here
}
type GRPCPortProtocol struct {
  // Future knobs can go here
}
type WebsocketPortProtocol struct {
  // Future knobs can go here
}
```

#### YAML API

```yaml
apiVersion: gateway.networking.k8s.io/v1alpha1
kind: BackendProtocol
metadata:
  name: some-service
  namespace: some-namespace
spec:
  ports:
  - port: 80
    http2: 
      encrypted: false # enable h2c
  - port: 80
    http1: {}          # We also listen to http1 on port 80
  - port: 9090
    grpc: {}
  - port: 8080
    websocket: {}      # enable websocket support on this port
  - port: 7070
    http1: {}
  targetRef:
    group: "" # corev1
    kind: Service
    name: some-service
```

### Multiple Protocol Meta-resources

Rather than bundle protocol details into a single resource an alternative would be to create distinct meta resources.
ie. `HTTP2Backend`, `GPRCBackend`, `WebsocketBackend`.

The advantages of this approach are:
- Easy to introduce new protocols
- Definitions/types would be simpler

The disadvantages of this approach are:
- N resources for N protocols need to be created to describe a single backend
- No easy mechanic to specify priority of protocols

### Re-using *Route objects

Route resources could be repurposed to also describe backend capabilities. For example we could have an HTTPRoute
with a parentRef to an existing Kubernetes Service on a specific port. This would imply the that port's protocol
is HTTP.

```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: HTTPRoute
metadata:
  name: httproute-example
spec:
  parentRefs:
  - name: acme-lb
    group: ""
    kind: Service
    port: 80
```

The advantages of this approach are:
- Single resource can describe downstream and upstream protocol support
- Protocol specific configuration needs to only be added to a single resource

The disadvantages of this approach are:
- Route objects are fairly complex (multiple parentRefs )- this would make it worse
- Has same disadvantages as multiple protocol metaresources

### Adding properties on Gateway Route Objects

From [GEP-1282](geps/gep-1282.md#tldr):
> some types of configuration requested by users are more about defining functionality that describes capabilities of the backend more than the route you take to get to the backend.

Backend protocol is specifying capabilities. This configuration is less about routing.

### Kubernetes Service - Expanding Protocol field

The `protocol` field on a Kubernetes service is used to specify a L4 protocol over IP. This field isn't appropriate to describe protocols
that operate at a higher 'application' level (eg. HTTP/GRPC etc.)

### Extending Kubernetes Service

This is considered untenable due to the 'the turnaround time for those changes can be years.' ([ref-1282](geps/gep-1282.md#non-goals):

### Unstructured Data/Special Values

Unstructured data refers to using labels and annotations.

From [GEP-1282](geps/gep-1282.md#non-goals):
> these are very sticky and hard to get rid of once you start using them.

Special values refers to using special strings in existing Kubernetes Resources.
For example Istio allows for protocol to be specified by prefixing the Kubernetes
Service's port name with the protocol (ie. `http-`, `grpc-`). This approach is
limiting as it doesn't allow for multiple protocols on the same port and future 
configuration per protocol. One protocol per port may be relaxed in the future see 
[KEP 1435](https://github.com/kubernetes/enhancements/tree/master/keps/sig-network/1435-mixed-protocol-lb)

Additionally, annotations are not self-documenting unlike CRD fields which can display
documentation via `kubectl explain`

## References

- GitHub Discussion - https://github.com/kubernetes-sigs/gateway-api/discussions/1244
- GEP-1282 - Describing Backend Properties
  - [GEP](geps/gep-1282.md)
  - [Issue](https://github.com/kubernetes-sigs/gateway-api/issues/1911)
- GEP-713 - Metaresources
  - [GEP](geps/gep-713.md)
- Linkerd Protocol Detection
  - https://linkerd.io/2.12/features/protocol-detection/
- Istio Protocol Selection 
  - https://istio.io/latest/docs/ops/configuration/traffic-management/protocol-selection/
- Contour Protocol Selection
  - Websockets - https://projectcontour.io/docs/1.24/config/websockets/
  - GRPC - https://projectcontour.io/docs/1.24/guides/grpc/#httpproxy-configuration


