# GEP-1651: Gateway Routability

* Issue: [#1651](https://github.com/kubernetes-sigs/gateway-api/issues/1651)
* Status: Provisional

(See status definitions [here](overview.md#status).)

## TLDR

Allow users to configure a Gateway so that it is only routable within
a specific scope (ie. public/cluster local)

## Goals

- Cluster local gateways can be created in a declarative way (`cluster`) and
  is accessible within a the bounds of the cluster's CNI
- Define a `public` scope for addresses that are accessible to the internet
- Implementations can define & support their own scopes

## Non-Goals

- Per-request/route scope
- Not a lightweight service mesh

## Introduction

One of the early feature requests for Knative was the ability to deploy an
application using Knative's HTTP routing support, but make it only available
within the cluster. I want to be able to specify both the "internal"
(service.namespace.svc) and "external" (service.namespace.example.com).
Gateways using the same GatewayClass on the cluster, but ensure that the
"internal" service is only routable within the cluster. This would greatly
simplify deployment for users over the instructions we have today.

The reason why we require an "internal" Gateway is so we can take advantage of
layer 7 load balancing for our internal services.

## API

We propose adding a new `routability` field under the `spec.infrastructure` stanza of a Gateway.

### Predefined Routability Values

Implementations MAY implement the following values for 'routability' and MUST abide by
their defined semantics.

Value | Semantic
-|-
`public`|The address is routable on the public internet
`cluster`|The address is routable inside the [cluster's network](https://kubernetes.io/docs/concepts/cluster-administration/networking/#how-to-implement-the-kubernetes-network-model)

### Vendor prefixed values

Implementations can define custom 'routability' values by specifying a vendor prefix followed
by a slash `/` and a custom name ie. `com.example.com/my-routability`.

### Default Routability
The default value of `routability` is implementation specific. It is RECOMMENDED that
the default `routability` remains consistent for Gateways with the same
`gatewayClassName`.

### Mutability
Implementations MAY prevent end-users from updating the `routability` value of a Gateway. If
updates are allowed the semantics and behaviour will depend on the underlying implementation.

### Go

```go

type GatewayRoutability string

const (
  GatewayRoutabilityPublic  GatewayRoutability  = "public"
  GatewayRoutabilityCluster GatewayRoutability  = "cluster"
)

type GatewaySpec struct {
  // Infrastructure defines infrastructure level attributes about this Gateway instance.
  Infrastructure GatewayInfrastructure `json:"infrastructure"`
  // ...
}
type GatewayInfrastructure struct {
  // AddressScope allows the Gateway to specify the accessibility of it's addresseses
  Routability GatewayRoutability `json:"routability"`
}
```

### YAML
```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: Gateway
metadata:
  name: prod-web
spec:
  gatewayClassName: acme-lb
  infrastructure:
    routability: public
  listeners:
  - protocol: HTTP
    port: 80
```

### Semantics

#### Interaction with GatewayClass

An infrastructure provider may provide a pre-defined set of GatewayClasses that limit the
routability choices of a Gateway. If the desired Gateway routability is incompatible with the
GatewayClass it MUST set the condition `Accepted` to `False` with `Reason` set to `Invalid`.

#### Unsupported routability & address values

If a Gateway is unable provide an address for the desired routability it MUST set the condition `Accepted` to `False` with `Reason` set to `Invalid`

#### Status.Addresses

If a Gateway supports the desired 'routability' implementations MUST populate the `status.addresses` with
an address with the desired routability semantic.

## Examples

#### 1. Request a GatewayAddress that is routable within the same cluster

```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: Gateway
metadata:
  name: prod-web
spec:
  gatewayClassName: acme-lb
  infrastructure:
    routability: cluster
  listeners:
  - protocol: HTTP
    port: 80
```
#### 2. Request a GatewayAddress with a specific routability and address
```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: Gateway
metadata:
  name: prod-web
spec:
  gatewayClassName: acme-lb
  infrastructure:
    routability: cluster
  listeners:
  - protocol: HTTP
    port: 80
  addresses:
  - value: 10.0.0.8
```
#### 3. Request a GatewayAddress that is routable on the public internet
```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: Gateway
metadata:
  name: prod-web
spec:
  gatewayClassName: acme-lb
  infrastructure:
    routability: public
  listeners:
  - protocol: HTTP
    port: 80
```

#### 4. Request a GatewayAddress that is a cloud provider's VPC
```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: Gateway
metadata:
  name: prod-web
spec:
  gatewayClassName: acme-lb
  infrastructure:
    routability: some.cloud.dev/vpc
  listeners:
  - protocol: HTTP
    port: 80
```

## Alternatives

### Introducing new GatewayAddress Types

We could introduce additional `AddressTypes` (ie. `ClusterLocalIPAddress`) but
this would lead to a combinatorial explosion as new dimensions (ie. IPv6) are
introduced.

From: https://github.com/kubernetes-sigs/gateway-api/pull/1653#issuecomment-1451246877

> Although this makes sense in isolation, I'm worried about the long term impacts this could have. In my opinion, ClusterLocal is a modifier, not exactly an address type. For example, it's possible in the future that we'll have a way to provision cluster-local DNS names, we may want to use the same kind of mechanism to request a ClusterLocal DNS name for the Gateway.
>
> It's also possible that users will want to explicitly request an IP Families (v4, v6, or both). I'd really hate to get into a situation where we have the following options:
>
>   IPAddress
>   IPv4Address
>   IPv6Address
>   ClusterLocalIPAddress
>   ClusterLocalIPv4Address
>   ClusterLocalIPv6Address
>
> For each dimension we avoid adding a separate field for and instead try to embed into a single name, we risk this kind of name explosion. Of course none of the above even begins to cover my idea of NetworkLocal which could further complicate this.

### Scope/reachability/routability field on GatewayAddress

This would allow Gateways to have multiple scopes.

From: https://github.com/kubernetes-sigs/gateway-api/pull/1653#issuecomment-1486271913
> The obvious application for multiple scopes seems to be saving on boilerplate, which is a win, but are there are any other advantages to allowing one Gateway to have multiple scopes?
>
> Multiple scopes Pros:
>
> Allows a single Gateway to express multiple networks, saving on needing to attach HTTPRoutes to multiple Gateways for each network scope.
>
> Multiple scopes Cons:
>
> Complicates the Gateway's purpose. Instead of one Gateway being one set of Listeners, now a Gateway is two sets of listeners that have a totally different scope (and presumably, security context). Personally, I'm also concerned how this will interact with other features like merging and preprovisioning that GEP-1867: Per-Gateway Infrastructure #1868 will allow.

### Adding `routability` attribute to GatewayClass

See [Prior Art - Multiple Gateways Classes](#multiple-gateway-classes)

## Survey of Prior Art

These alternatives are a survey of existing approaches to support cluster
local Gateways. Most are implementation specific and are not portable.

### Special annotation/label

Istio let's you specify an annotation `networking.istio.io/service-type` to
change the underlying Kubernetes Service type to make it a ClusterIP type.

### Re-use of AddressType Hostname

Istio let's you re-use existing Gateway deployments by setting the address
type to `Hostname` and the value to the Istio ingress Kubernetes Service. If an
operator configures the Istio deployment to support cluster local traffic a
Gateway implementation can select it using the `HostName` attribute.

### Multiple Gateway Classes

Some implementations support multiple deployments on a single cluster where each maps to a
GatewayClass. One of these deployments can be configured to serve cluster local traffic. This is
sub-optimal because this is implementation specific and the end-user is effectively managing the
deployments themselves rather than infrastructure being automatically provisioned.

Likewise, infrastructure providers may provide a fixed set of GatewayClasses with unique and fixed
routability. Thus GatewayClass name is a viable option to control routability. There may be a
non-zero cost when requiring additional GatewayClasses - but this depends on the implementation.

Additionally, if more attributes are added to GatewayClass to constrain Gateways in some
form this leads to a combinatorial number of GatewayClassNames. For example, `foo-public` and
`foo-cluster` are two GatewayClasses surfacing the values of a single attribute `routability`.
Let's say we want to enforce address types to just IP then our `gatewayClassName` would be:
- `foo-public-ipv4`
- `foo-public-ipv6`
- `foo-cluster-ipv4`
- `foo-cluster-ipv6`

This may not be as flexible for end-users compared to configuring `routability` when creating
a Gateway.

As howardjohn mentioned [here](https://github.com/kubernetes-sigs/gateway-api/pull/1653#issuecomment-1429992160):
> having the ability to configure things at a higher level seems nice for Gateway, but being able to configure them on a per-Gateway basis remains important.

## References

- Knative - Private Services - https://knative.dev/docs/serving/services/private-services/#configuring-private-services
- Initial Gateway GitHub Discussion - https://github.com/kubernetes-sigs/gateway-api/discussions/1247
- Istio Support for Private Gateways - https://istio.io/latest/docs/tasks/traffic-management/ingress/gateway-api/#automated-deployment
- Envoy Gateway Support for Private Gateways - https://gateway.envoyproxy.io/latest/api/config_types.html#kubernetesservicespec

