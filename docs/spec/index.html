



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>API specification - Kubernetes Service APIs</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.1b62728e.css">
      
      
    
    
      <script src="../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href=".." title="Kubernetes Service APIs" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Kubernetes Service APIs
            </span>
            <span class="md-header-nav__topic">
              
                API specification
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="http://sigs.k8s.io/service-apis" title="Go to repository" class="md-source" data-md-source="">
  
  <div class="md-source__repository">
    GitHub
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href=".." title="Kubernetes Service APIs" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    Kubernetes Service APIs
  </label>
  
    <div class="md-nav__source">
      


  

<a href="http://sigs.k8s.io/service-apis" title="Go to repository" class="md-source" data-md-source="">
  
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Introduction" class="md-nav__link">
      Introduction
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Concepts
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Concepts
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../concepts/" title="API concepts" class="md-nav__link">
      API concepts
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../resources/" title="API resources" class="md-nav__link">
      API resources
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../security-model/" title="Security Model" class="md-nav__link">
      Security Model
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../guidelines/" title="Implementation Guidelines" class="md-nav__link">
      Implementation Guidelines
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Guides
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Guides
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../guides/" title="Introduction" class="md-nav__link">
      Introduction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../getting-started/" title="Getting started" class="md-nav__link">
      Getting started
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../multiple-ns/" title="Multiple namespaces and routes" class="md-nav__link">
      Multiple namespaces and routes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tls/" title="TLS" class="md-nav__link">
      TLS
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      References
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        References
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
    <a href="./" title="API specification" class="md-nav__link md-nav__link--active">
      API specification
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../releases/" title="Releases" class="md-nav__link">
      Releases
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Contributing
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Contributing
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../devguide/" title="Developer guide" class="md-nav__link">
      Developer guide
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../enhancement-requests/" title="Enhancement requests" class="md-nav__link">
      Enhancement requests
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../community/" title="Community" class="md-nav__link">
      Community
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../faq/" title="FAQ" class="md-nav__link">
      FAQ
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  <h1>API specification</h1>
                
                <p>Packages:</p>

<ul>
<li>
<a href="#networking.x-k8s.io%2fv1alpha1">networking.x-k8s.io/v1alpha1</a>
</li>
</ul>

<h2 id="networking.x-k8s.io/v1alpha1">networking.x-k8s.io/v1alpha1</h2>

<p>
<p>Package v1alpha1 contains API Schema definitions for the networking.x-k8s.io
API group.</p>
</p>

<p>Resource Types:
<ul><li>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicy">BackendPolicy</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.Gateway">Gateway</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClass">GatewayClass</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRoute">HTTPRoute</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.TCPRoute">TCPRoute</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.TLSRoute">TLSRoute</a>
</li><li>
<a href="#networking.x-k8s.io/v1alpha1.UDPRoute">UDPRoute</a>
</li></ul>
<h3 id="networking.x-k8s.io/v1alpha1.BackendPolicy">BackendPolicy
</h3>
<p>
<p>BackendPolicy defines policies associated with backends. For the purpose of
this API, a backend is defined as any resource that a route can forward
traffic to. A common example of a backend is a Service. Configuration that is
implementation specific may be represented with similar implementation
specific custom resources.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>BackendPolicy</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicySpec">
BackendPolicySpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>backendRefs</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendRef">
[]BackendRef
</a>
</em>
</td>
<td>
<p>BackendRefs define which backends this policy should be applied to. This
policy can only apply to backends within the same namespace. If more than
one BackendPolicy targets the same backend, precedence must be given to
the oldest BackendPolicy.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendTLSConfig">
BackendTLSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS is the TLS configuration for these backends.</p>
<p>Support: Extended</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicyStatus">
BackendPolicyStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.Gateway">Gateway
</h3>
<p>
<p>Gateway represents an instantiation of a service-traffic handling
infrastructure by binding Listeners to a set of IP addresses.</p>
<p>Implementations should add the <code>gateway-exists-finalizer.networking.x-k8s.io</code>
finalizer on the associated GatewayClass whenever Gateway(s) is running.
This ensures that a GatewayClass associated with a Gateway(s) is not
deleted while in use.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>Gateway</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewaySpec">
GatewaySpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>gatewayClassName</code></br>
<em>
string
</em>
</td>
<td>
<p>GatewayClassName used for this Gateway. This is the name of a
GatewayClass resource.</p>
</td>
</tr>
<tr>
<td>
<code>listeners</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Listener">
[]Listener
</a>
</em>
</td>
<td>
<p>Listeners associated with this Gateway. Listeners define
logical endpoints that are bound on this Gateway&rsquo;s addresses.
At least one Listener MUST be specified.</p>
<p>An implementation MAY group Listeners by Port and then collapse each
group of Listeners into a single Listener if the implementation
determines that the Listeners in the group are &ldquo;compatible&rdquo;. An
implementation MAY also group together and collapse compatible
Listeners belonging to different Gateways.</p>
<p>For example, an implementation might consider Listeners to be
compatible with each other if all of the following conditions are
met:</p>
<ol>
<li><p>Either each Listener within the group specifies the &ldquo;HTTP&rdquo;
Protocol or each Listener within the group specifies either
the &ldquo;HTTPS&rdquo; or &ldquo;TLS&rdquo; Protocol.</p></li>
<li><p>Each Listener within the group specifies a Hostname that is unique
within the group.</p></li>
<li><p>As a special case, one Listener within a group may omit Hostname,
in which case this Listener matches when no other Listener
matches.</p></li>
</ol>
<p>If the implementation does collapse compatible Listeners, the
hostname provided in the incoming client request MUST be
matched to a Listener to find the correct set of Routes.
The incoming hostname MUST be matched using the Hostname
field for each Listener in order of most to least specific.
That is, exact matches must be processed before wildcard
matches.</p>
<p>If this field specifies multiple Listeners that have the same
Port value but are not compatible, the implementation must raise
a &ldquo;Conflicted&rdquo; condition in the Listener status.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>addresses</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayAddress">
[]GatewayAddress
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Addresses requested for this gateway. This is optional and
behavior can depend on the GatewayClass. If a value is set
in the spec and the requested address is invalid, the
GatewayClass MUST indicate this in the associated entry in
GatewayStatus.Addresses.</p>
<p>If no Addresses are specified, the GatewayClass may
schedule the Gateway in an implementation-defined manner,
assigning an appropriate set of Addresses.</p>
<p>The GatewayClass MUST bind all Listeners to every
GatewayAddress that it assigns to the Gateway.</p>
<p>Support: Core</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayStatus">
GatewayStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayClass">GatewayClass
</h3>
<p>
<p>GatewayClass describes a class of Gateways available to the user
for creating Gateway resources.</p>
<p>GatewayClass is a Cluster level resource.</p>
<p>Support: Core.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>GatewayClass</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClassSpec">
GatewayClassSpec
</a>
</em>
</td>
<td>
<p>Spec for this GatewayClass.</p>
<br/>
<br/>
<table>
<tr>
<td>
<code>controller</code></br>
<em>
string
</em>
</td>
<td>
<p>Controller is a domain/path string that indicates the
controller that is managing Gateways of this class.</p>
<p>Example: &ldquo;acme.io/gateway-controller&rdquo;.</p>
<p>This field is not mutable and cannot be empty.</p>
<p>The format of this field is DOMAIN &ldquo;/&rdquo; PATH, where DOMAIN
and PATH are valid Kubernetes names
(<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names">https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</a>).</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>parametersRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ParametersRef is a controller-specific resource containing the
configuration parameters corresponding to this class. This is optional if
the controller does not require any additional configuration.</p>
<p>Parameters resources are implementation specific custom resources. These
resources must be cluster-scoped.</p>
<p>If the referent cannot be found, the GatewayClass&rsquo;s &ldquo;InvalidParameters&rdquo;
status condition will be true.</p>
<p>Support: Custom</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClassStatus">
GatewayClassStatus
</a>
</em>
</td>
<td>
<p>Status of the GatewayClass.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRoute">HTTPRoute
</h3>
<p>
<p>HTTPRoute is the Schema for the HTTPRoute resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>HTTPRoute</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteSpec">
HTTPRouteSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
<tr>
<td>
<code>hostnames</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Hostname">
[]Hostname
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Hostnames defines a set of hostname that should match against
the HTTP Host header to select a HTTPRoute to process the request.
Hostname is the fully qualified domain name of a network host,
as defined by RFC 3986. Note the following deviations from the
&ldquo;host&rdquo; part of the URI as defined in the RFC:</p>
<ol>
<li>IPs are not allowed.</li>
<li>The <code>:</code> delimiter is not respected because ports are not allowed.</li>
</ol>
<p>Incoming requests are matched against the hostnames before the
HTTPRoute rules. If no hostname is specified, traffic is routed
based on the HTTPRouteRules.</p>
<p>Hostname can be &ldquo;precise&rdquo; which is a domain name without the terminating
dot of a network host (e.g. &ldquo;foo.example.com&rdquo;) or &ldquo;wildcard&rdquo;, which is
a domain name prefixed with a single wildcard label (e.g. &ldquo;<em>.example.com&rdquo;).
The wildcard character &lsquo;</em>&rsquo; must appear by itself as the first DNS
label and matches only a single label.
You cannot have a wildcard label by itself (e.g. Host == &ldquo;<em>&rdquo;).
Requests will be matched against the Host field in the following order:
1. If Host is precise, the request matches this rule if
the http host header is equal to Host.
2. If Host is a wildcard, then the request matches this rule if
the http host header is to equal to the suffix
(removing the first label) of the wildcard rule.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteTLSConfig">
RouteTLSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS defines the TLS certificate to use for Hostnames defined in this
Route. This configuration only takes effect if the AllowRouteOverride
field is set to true in the associated Gateway resource.</p>
<p>Collisions can happen if multiple HTTPRoutes define a TLS certificate
for the same hostname. In such a case, conflict resolution guiding
principles apply, specificallly, if hostnames are same and two different
certificates are specified then the certificate in the
oldest resource wins.</p>
<p>Please note that HTTP Route-selection takes place after the
TLS Handshake (ClientHello). Due to this, TLS certificate defined
here will take precedence even if the request has the potential to
match multiple routes (in case multiple HTTPRoutes share the same
hostname).</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteRule">
[]HTTPRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of HTTP matchers, filters and actions.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteStatus">
HTTPRouteStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TCPRoute">TCPRoute
</h3>
<p>
<p>TCPRoute is the Schema for the TCPRoute resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>TCPRoute</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteSpec">
TCPRouteSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteRule">
[]TCPRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of TCP matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteStatus">
TCPRouteStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRoute">TLSRoute
</h3>
<p>
<p>TLSRoute is the Schema for the TLSRoute resource. TLSRoute is similar to
TCPRoute but can be configured to match against TLS-specific metadata.
This allows more flexibility in matching streams for a given TLS listener.</p>
<p>If you need to forward traffic to a single target for a TLS listener, you
could chose to use a TCPRoute with a TLS listener.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>TLSRoute</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteSpec">
TLSRouteSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteRule">
[]TLSRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of TLS matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteStatus">
TLSRouteStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.UDPRoute">UDPRoute
</h3>
<p>
<p>UDPRoute is the Schema for the UDPRoute resource.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code></br>
string</td>
<td>
<code>
networking.x-k8s.io/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
string
</td>
<td><code>UDPRoute</code></td>
</tr>
<tr>
<td>
<code>metadata</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteSpec">
UDPRouteSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteRule">
[]UDPRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of UDP matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteStatus">
UDPRouteStatus
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.AddressType">AddressType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayAddress">GatewayAddress</a>)
</p>
<p>
<p>AddressType defines how a network address is represented as a text string.
Valid AddressType values are:</p>
<ul>
<li>&ldquo;IPAddress&rdquo;</li>
<li>&ldquo;NamedAddress&rdquo;</li>
</ul>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.BackendPolicyConditionType">BackendPolicyConditionType
(<code>string</code> alias)</p></h3>
<p>
<p>BackendPolicyConditionType is a type of condition associated with a
BackendPolicy.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.BackendPolicySpec">BackendPolicySpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicy">BackendPolicy</a>)
</p>
<p>
<p>BackendPolicySpec defines desired policy for a backend.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>backendRefs</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendRef">
[]BackendRef
</a>
</em>
</td>
<td>
<p>BackendRefs define which backends this policy should be applied to. This
policy can only apply to backends within the same namespace. If more than
one BackendPolicy targets the same backend, precedence must be given to
the oldest BackendPolicy.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.BackendTLSConfig">
BackendTLSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS is the TLS configuration for these backends.</p>
<p>Support: Extended</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.BackendPolicyStatus">BackendPolicyStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicy">BackendPolicy</a>)
</p>
<p>
<p>BackendPolicyStatus defines the observed state of BackendPolicy. Conditions
that are related to a specific Route or Gateway should be placed on the
Route(s) using backends configured by this BackendPolicy.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#condition-v1-meta">
[]Kubernetes meta/v1.Condition
</a>
</em>
</td>
<td>
<p>Conditions describe the current conditions of the BackendPolicy.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.BackendRef">BackendRef
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicySpec">BackendPolicySpec</a>)
</p>
<p>
<p>BackendRef identifies an API object within a known namespace that defaults
group to core and resource to services if unspecified.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>group</code></br>
<em>
string
</em>
</td>
<td>
<p>Group is the group of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind is the kind of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<p>Name is the name of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Port is the port of the referent. If unspecified, this policy applies to
all ports on the backend.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.BackendTLSConfig">BackendTLSConfig
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendPolicySpec">BackendPolicySpec</a>)
</p>
<p>
<p>BackendTLSConfig describes TLS configuration for a backend.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>certificateAuthorityRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CertificateAuthorityRef is a reference to a resource that includes
trusted CA certificates for the associated backends. If an entry in this
list omits or specifies the empty string for both the group and the
resource, the resource defaults to &ldquo;secrets&rdquo;. An implementation may
support other resources (for example, resource &ldquo;mycertificates&rdquo; in group
&ldquo;networking.acme.io&rdquo;).</p>
<p>When stored in a Secret, certificates must be PEM encoded and specified
within the &ldquo;ca.crt&rdquo; data field of the Secret. Multiple certificates can
be specified, concatenated by new lines.</p>
<p>Support: Extended</p>
</td>
</tr>
<tr>
<td>
<code>options</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Options are a list of key/value pairs to give extended options to the
provider.</p>
<p>Support: Implementation-specific.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayAddress">GatewayAddress
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewaySpec">GatewaySpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.GatewayStatus">GatewayStatus</a>)
</p>
<p>
<p>GatewayAddress describes an address that can be bound to a Gateway.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.AddressType">
AddressType
</a>
</em>
</td>
<td>
<p>Type of the Address. This is either &ldquo;IPAddress&rdquo; or &ldquo;NamedAddress&rdquo;.</p>
<p>Support: Extended</p>
</td>
</tr>
<tr>
<td>
<code>value</code></br>
<em>
string
</em>
</td>
<td>
<p>Value. Examples: &ldquo;1.2.3.4&rdquo;, &ldquo;128::1&rdquo;, &ldquo;my-ip-address&rdquo;. Validity of the
values will depend on <code>Type</code> and support by the controller.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayAllowType">GatewayAllowType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">RouteGateways</a>)
</p>
<p>
<p>GatewayAllowType specifies which Gateways should be allowed to use a Route.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayClassConditionType">GatewayClassConditionType
(<code>string</code> alias)</p></h3>
<p>
<p>GatewayClassConditionType is the type of status conditions. This
type should be used with the GatewayClassStatus.Conditions field.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayClassSpec">GatewayClassSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClass">GatewayClass</a>)
</p>
<p>
<p>GatewayClassSpec reflects the configuration of a class of Gateways.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>controller</code></br>
<em>
string
</em>
</td>
<td>
<p>Controller is a domain/path string that indicates the
controller that is managing Gateways of this class.</p>
<p>Example: &ldquo;acme.io/gateway-controller&rdquo;.</p>
<p>This field is not mutable and cannot be empty.</p>
<p>The format of this field is DOMAIN &ldquo;/&rdquo; PATH, where DOMAIN
and PATH are valid Kubernetes names
(<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names">https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</a>).</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>parametersRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ParametersRef is a controller-specific resource containing the
configuration parameters corresponding to this class. This is optional if
the controller does not require any additional configuration.</p>
<p>Parameters resources are implementation specific custom resources. These
resources must be cluster-scoped.</p>
<p>If the referent cannot be found, the GatewayClass&rsquo;s &ldquo;InvalidParameters&rdquo;
status condition will be true.</p>
<p>Support: Custom</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayClassStatus">GatewayClassStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayClass">GatewayClass</a>)
</p>
<p>
<p>GatewayClassStatus is the current status for the GatewayClass.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#condition-v1-meta">
[]Kubernetes meta/v1.Condition
</a>
</em>
</td>
<td>
<p>Conditions is the current status from the controller for
this GatewayClass.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayConditionReason">GatewayConditionReason
(<code>string</code> alias)</p></h3>
<p>
<p>GatewayConditionReason defines the set of reasons that explain
why a particular Gateway condition type has been raised.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayConditionType">GatewayConditionType
(<code>string</code> alias)</p></h3>
<p>
<p>GatewayConditionType is a type of condition associated with a
Gateway. This type should be used with the GatewayStatus.Conditions
field.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayReference">GatewayReference
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGatewayStatus">RouteGatewayStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">RouteGateways</a>)
</p>
<p>
<p>GatewayReference identifies a Gateway in a specified namespace.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<p>Name is the name of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>namespace</code></br>
<em>
string
</em>
</td>
<td>
<p>Namespace is the namespace of the referent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewaySpec">GatewaySpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.Gateway">Gateway</a>)
</p>
<p>
<p>GatewaySpec defines the desired state of Gateway.</p>
<p>Not all possible combinations of options specified in the Spec are
valid. Some invalid configurations can be caught synchronously via a
webhook, but there are many cases that will require asynchronous
signaling via the GatewayStatus block.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>gatewayClassName</code></br>
<em>
string
</em>
</td>
<td>
<p>GatewayClassName used for this Gateway. This is the name of a
GatewayClass resource.</p>
</td>
</tr>
<tr>
<td>
<code>listeners</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Listener">
[]Listener
</a>
</em>
</td>
<td>
<p>Listeners associated with this Gateway. Listeners define
logical endpoints that are bound on this Gateway&rsquo;s addresses.
At least one Listener MUST be specified.</p>
<p>An implementation MAY group Listeners by Port and then collapse each
group of Listeners into a single Listener if the implementation
determines that the Listeners in the group are &ldquo;compatible&rdquo;. An
implementation MAY also group together and collapse compatible
Listeners belonging to different Gateways.</p>
<p>For example, an implementation might consider Listeners to be
compatible with each other if all of the following conditions are
met:</p>
<ol>
<li><p>Either each Listener within the group specifies the &ldquo;HTTP&rdquo;
Protocol or each Listener within the group specifies either
the &ldquo;HTTPS&rdquo; or &ldquo;TLS&rdquo; Protocol.</p></li>
<li><p>Each Listener within the group specifies a Hostname that is unique
within the group.</p></li>
<li><p>As a special case, one Listener within a group may omit Hostname,
in which case this Listener matches when no other Listener
matches.</p></li>
</ol>
<p>If the implementation does collapse compatible Listeners, the
hostname provided in the incoming client request MUST be
matched to a Listener to find the correct set of Routes.
The incoming hostname MUST be matched using the Hostname
field for each Listener in order of most to least specific.
That is, exact matches must be processed before wildcard
matches.</p>
<p>If this field specifies multiple Listeners that have the same
Port value but are not compatible, the implementation must raise
a &ldquo;Conflicted&rdquo; condition in the Listener status.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>addresses</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayAddress">
[]GatewayAddress
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Addresses requested for this gateway. This is optional and
behavior can depend on the GatewayClass. If a value is set
in the spec and the requested address is invalid, the
GatewayClass MUST indicate this in the associated entry in
GatewayStatus.Addresses.</p>
<p>If no Addresses are specified, the GatewayClass may
schedule the Gateway in an implementation-defined manner,
assigning an appropriate set of Addresses.</p>
<p>The GatewayClass MUST bind all Listeners to every
GatewayAddress that it assigns to the Gateway.</p>
<p>Support: Core</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayStatus">GatewayStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.Gateway">Gateway</a>)
</p>
<p>
<p>GatewayStatus defines the observed state of Gateway.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>addresses</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayAddress">
[]GatewayAddress
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Addresses lists the IP addresses that have actually been
bound to the Gateway. These addresses may differ from the
addresses in the Spec, e.g. if the Gateway automatically
assigns an address from a reserved pool.</p>
<p>These addresses should all be of type &ldquo;IPAddress&rdquo;.</p>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#condition-v1-meta">
[]Kubernetes meta/v1.Condition
</a>
</em>
</td>
<td>
<p>Conditions describe the current conditions of the Gateway.</p>
<p>Implementations should prefer to express Gateway conditions
using the <code>GatewayConditionType</code> and <code>GatewayConditionReason</code>
constants so that operators and tools can converge on a common
vocabulary to describe Gateway state.</p>
<p>Known condition types are:</p>
<ul>
<li>&ldquo;Scheduled&rdquo;</li>
<li>&ldquo;Ready&rdquo;</li>
</ul>
</td>
</tr>
<tr>
<td>
<code>listeners</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.ListenerStatus">
[]ListenerStatus
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Listeners provide status for each unique listener port defined in the Spec.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.GatewayTLSConfig">GatewayTLSConfig
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.Listener">Listener</a>)
</p>
<p>
<p>GatewayTLSConfig describes a TLS configuration.</p>
<p>References
- nginx: <a href="https://nginx.org/en/docs/http/configuring_https_servers.html">https://nginx.org/en/docs/http/configuring_https_servers.html</a>
- envoy: <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto">https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto</a>
- haproxy: <a href="https://www.haproxy.com/documentation/aloha/9-5/traffic-management/lb-layer7/tls/">https://www.haproxy.com/documentation/aloha/9-5/traffic-management/lb-layer7/tls/</a>
- gcp: <a href="https://cloud.google.com/load-balancing/docs/use-ssl-policies#creating_an_ssl_policy_with_a_custom_profile">https://cloud.google.com/load-balancing/docs/use-ssl-policies#creating_an_ssl_policy_with_a_custom_profile</a>
- aws: <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies</a>
- azure: <a href="https://docs.microsoft.com/en-us/azure/app-service/configure-ssl-bindings#enforce-tls-1112">https://docs.microsoft.com/en-us/azure/app-service/configure-ssl-bindings#enforce-tls-1112</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>mode</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSModeType">
TLSModeType
</a>
</em>
</td>
<td>
<p>Mode defines the TLS behavior for the TLS session initiated by the client.
There are two possible modes:
- Terminate: The TLS session between the downstream client
and the Gateway is terminated at the Gateway.
- Passthrough: The TLS session is NOT terminated by the Gateway. This
implies that the Gateway can&rsquo;t decipher the TLS stream except for
the ClientHello message of the TLS protocol.
CertificateRef field is ignored in this mode.</p>
</td>
</tr>
<tr>
<td>
<code>certificateRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>CertificateRef is the reference to Kubernetes object that
contain a TLS certificate and private key.
This certificate MUST be used for TLS handshakes for the domain
this GatewayTLSConfig is associated with.
If an entry in this list omits or specifies the empty
string for both the group and the resource, the resource defaults to &ldquo;secrets&rdquo;.
An implementation may support other resources (for example, resource
&ldquo;mycertificates&rdquo; in group &ldquo;networking.acme.io&rdquo;).
Support: Core (Kubernetes Secrets)
Support: Implementation-specific (Other resource types)</p>
</td>
</tr>
<tr>
<td>
<code>routeOverride</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSOverridePolicy">
TLSOverridePolicy
</a>
</em>
</td>
<td>
<p>RouteOverride dictates if TLS settings can be configured
via Routes or not.</p>
<p>CertificateRef must be defined even if <code>routeOverride.certificate</code> is
set to &lsquo;Allow&rsquo; as it will be used as the default certificate for the
listener.</p>
</td>
</tr>
<tr>
<td>
<code>options</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Options are a list of key/value pairs to give extended options
to the provider.</p>
<p>There variation among providers as to how ciphersuites are
expressed. If there is a common subset for expressing ciphers
then it will make sense to loft that as a core API
construct.</p>
<p>Support: Implementation-specific.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPHeaderMatch">HTTPHeaderMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteMatch">HTTPRouteMatch</a>)
</p>
<p>
<p>HTTPHeaderMatch describes how to select a HTTP route by matching HTTP request
headers.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HeaderMatchType">
HeaderMatchType
</a>
</em>
</td>
<td>
<p>Type specifies how to match against the value of the header.</p>
<p>Support: core (Exact)
Support: custom (RegularExpression, ImplementationSpecific)</p>
<p>Since RegularExpression PathType has custom conformance, implementations
can support POSIX, PCRE or any other dialects of regular expressions.
Please read the implementation&rsquo;s documentation to determine the supported
dialect.</p>
<p>HTTP Header name matching MUST be case-insensitive (RFC 2616 - section 4.2).</p>
</td>
</tr>
<tr>
<td>
<code>values</code></br>
<em>
map[string]string
</em>
</td>
<td>
<p>Values is a map of HTTP Headers to be matched.
It MUST contain at least one entry.</p>
<p>The HTTP header field name to match is the map key, and the
value of the HTTP header is the map value. HTTP header field name matching
MUST be case-insensitive.</p>
<p>Multiple match values are ANDed together, meaning, a request
must match all the specified headers to select the route.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPPathMatch">HTTPPathMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteMatch">HTTPRouteMatch</a>)
</p>
<p>
<p>HTTPPathMatch describes how to select a HTTP route by matching the HTTP request path.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PathMatchType">
PathMatchType
</a>
</em>
</td>
<td>
<p>Type specifies how to match against the path Value.</p>
<p>Support: core (Exact, Prefix)
Support: custom (RegularExpression, ImplementationSpecific)</p>
<p>Since RegularExpression PathType has custom conformance, implementations
can support POSIX, PCRE or any other dialects of regular expressions.
Please read the implementation&rsquo;s documentation to determine the supported
dialect.</p>
</td>
</tr>
<tr>
<td>
<code>value</code></br>
<em>
string
</em>
</td>
<td>
<p>Value of the HTTP path to match against.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRequestHeaderFilter">HTTPRequestHeaderFilter
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">HTTPRouteFilter</a>)
</p>
<p>
<p>HTTPRequestHeaderFilter defines configuration for the RequestHeaderModifier
filter.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>add</code></br>
<em>
map[string]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Add adds the given header (name, value) to the request
before the action.</p>
<p>Input:
GET /foo HTTP/1.1</p>
<p>Config:
add: {&ldquo;my-header&rdquo;: &ldquo;foo&rdquo;}</p>
<p>Output:
GET /foo HTTP/1.1
my-header: foo</p>
<p>Support: Extended</p>
</td>
</tr>
<tr>
<td>
<code>remove</code></br>
<em>
[]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Remove the given header(s) from the HTTP request before the
action. The value of RemoveHeader is a list of HTTP header
names. Note that the header names are case-insensitive
[RFC-2616 4.2].</p>
<p>Input:
GET /foo HTTP/1.1
My-Header1: ABC
My-Header2: DEF
My-Header2: GHI</p>
<p>Config:
remove: [&ldquo;my-header1&rdquo;, &ldquo;my-header3&rdquo;]</p>
<p>Output:
GET /foo HTTP/1.1
My-Header2: DEF</p>
<p>Support: Extended</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRequestMirrorFilter">HTTPRequestMirrorFilter
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">HTTPRouteFilter</a>)
</p>
<p>
<p>HTTPRequestMirrorFilter defines configuration for the RequestMirror filter.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceName refers to the name of the Service to mirror matched requests
to. When specified, this takes the place of BackendRef. If both
BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the rule is not included in the route.
The controller should raise the &ldquo;ResolvedRefs&rdquo; condition on the Gateway
with the &ldquo;DegradedRoutes&rdquo; reason. The gateway status for this route should
be updated with a condition that describes the error more specifically.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>backendRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>BackendRef is a local object reference to mirror matched requests to. If
both BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the rule is not included in the route.
The controller should raise the &ldquo;ResolvedRefs&rdquo; condition on the Gateway
with the &ldquo;DegradedRoutes&rdquo; reason. The gateway status for this route should
be updated with a condition that describes the error more specifically.</p>
<p>Support: Custom</p>
</td>
</tr>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<p>Port specifies the destination port number to use for the
backend referenced by the ServiceName or BackendRef field.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteFilter">HTTPRouteFilter
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteForwardTo">HTTPRouteForwardTo</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteRule">HTTPRouteRule</a>)
</p>
<p>
<p>HTTPRouteFilter defines additional processing steps that must be completed
during the request or response lifecycle. HTTPRouteFilters are meant as an
extension point to express additional processing that may be done in Gateway
implementations. Some examples include request or response modification,
implementing authentication strategies, rate-limiting, and traffic shaping.
API guarantee/conformance is defined based on the type of the filter.
TODO(hbagdi): re-render CRDs once controller-tools supports union tags:
- <a href="https://github.com/kubernetes-sigs/controller-tools/pull/298">https://github.com/kubernetes-sigs/controller-tools/pull/298</a>
- <a href="https://github.com/kubernetes-sigs/controller-tools/issues/461">https://github.com/kubernetes-sigs/controller-tools/issues/461</a></p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>type</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilterType">
HTTPRouteFilterType
</a>
</em>
</td>
<td>
<p>Type identifies the type of filter to apply. As with other API fields,
types are classified into three conformance levels:</p>
<ul>
<li><p>Core: Filter types and their corresponding configuration defined by
&ldquo;Support: Core&rdquo; in this package, e.g. &ldquo;RequestHeaderModifier&rdquo;. All
implementations must support core filters.</p></li>
<li><p>Extended: Filter types and their corresponding configuration defined by
&ldquo;Support: Extended&rdquo; in this package, e.g. &ldquo;RequestMirror&rdquo;. Implementers
are encouraged to support extended filters.</p></li>
<li><p>Custom: Filters that are defined and supported by specific vendors.
In the future, filters showing convergence in behavior across multiple
implementations will be considered for inclusion in extended or core
conformance levels. Filter-specific configuration for such filters
is specified using the ExtensionRef field. <code>Type</code> should be set to
&ldquo;ExtensionRef&rdquo; for custom filters.</p></li>
</ul>
<p>Implementers are encouraged to define custom implementation types to
extend the core API with implementation-specific behavior.</p>
</td>
</tr>
<tr>
<td>
<code>requestHeaderModifier</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRequestHeaderFilter">
HTTPRequestHeaderFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>RequestHeaderModifier defines a schema for a filter that modifies request
headers.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>requestMirror</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRequestMirrorFilter">
HTTPRequestMirrorFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>RequestMirror defines a schema for a filter that mirrors requests.</p>
<p>Support: Extended</p>
</td>
</tr>
<tr>
<td>
<code>extensionRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ExtensionRef is an optional, implementation-specific extension to the
&ldquo;filter&rdquo; behavior.  For example, resource &ldquo;myroutefilter&rdquo; in group
&ldquo;networking.acme.io&rdquo;). ExtensionRef MUST NOT be used for core and
extended filters.</p>
<p>Support: Implementation-specific</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteFilterType">HTTPRouteFilterType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">HTTPRouteFilter</a>)
</p>
<p>
<p>HTTPRouteFilterType identifies a type of HTTPRoute filter.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteForwardTo">HTTPRouteForwardTo
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteRule">HTTPRouteRule</a>)
</p>
<p>
<p>HTTPRouteForwardTo defines how a HTTPRoute should forward a request.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceName refers to the name of the Service to forward matched requests
to. When specified, this takes the place of BackendRef. If both
BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the route must be dropped
from the Gateway. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DroppedRoutes&rdquo; reason.
The gateway status for this route should be updated with a
condition that describes the error more specifically.</p>
<p>The protocol to use should be specified with the AppProtocol field on Service
resources. This field was introduced in Kubernetes 1.18. If using an earlier version
of Kubernetes, a <code>networking.x-k8s.io/app-protocol</code> annotation on the
BackendPolicy resource may be used to define the protocol. If the
AppProtocol field is available, this annotation should not be used. The
AppProtocol field, when populated, takes precedence over the annotation
in the BackendPolicy resource. For custom backends, it is encouraged to
add a semantically-equivalent field in the Custom Resource Definition.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>backendRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>BackendRef is a reference to a backend to forward matched requests to. If
both BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the route must be dropped
from the Gateway. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DroppedRoutes&rdquo; reason.
The gateway status for this route should be updated with a
condition that describes the error more specifically.</p>
<p>Support: Custom</p>
</td>
</tr>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<p>Port specifies the destination port number to use for the
backend referenced by the ServiceName or BackendRef field.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>weight</code></br>
<em>
int32
</em>
</td>
<td>
<p>Weight specifies the proportion of HTTP requests forwarded to the backend
referenced by the ServiceName or BackendRef field. This is computed as
weight/(sum of all weights in this ForwardTo list). For non-zero values,
there may be some epsilon from the exact proportion defined here
depending on the precision an implementation supports. Weight is not a
percentage and the sum of weights does not need to equal 100.</p>
<p>If only one backend is specified and it has a weight greater than 0, 100%
of the traffic is forwarded to that backend. If weight is set to 0, no
traffic should be forwarded for this entry. If unspecified, weight
defaults to 1.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>filters</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">
[]HTTPRouteFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Filters defined at this-level should be executed if and only if the
request is being forwarded to the backend defined here.</p>
<p>Support: Custom (For broader support of filters, use the Filters field
in HTTPRouteRule.)</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteMatch">HTTPRouteMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteRule">HTTPRouteRule</a>)
</p>
<p>
<p>HTTPRouteMatch defines the predicate used to match requests to a given
action. Multiple match types are ANDed together, i.e. the match will
evaluate to true only if all conditions are satisfied.</p>
<p>For example, the match below will match a HTTP request only if its path
starts with <code>/foo</code> AND it contains the <code>version: &quot;1&quot;</code> header:</p>
<pre><code>match:
path:
value: &quot;/foo&quot;
headers:
values:
version: &quot;1&quot;
</code></pre>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>path</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPPathMatch">
HTTPPathMatch
</a>
</em>
</td>
<td>
<p>Path specifies a HTTP request path matcher. If this field is not
specified, a default prefix match on the &ldquo;/&rdquo; path is provided.</p>
</td>
</tr>
<tr>
<td>
<code>headers</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPHeaderMatch">
HTTPHeaderMatch
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Headers specifies a HTTP request header matcher.</p>
</td>
</tr>
<tr>
<td>
<code>extensionRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ExtensionRef is an optional, implementation-specific extension to the
&ldquo;match&rdquo; behavior. For example, resource &ldquo;myroutematcher&rdquo; in group
&ldquo;networking.acme.io&rdquo;. If the referent cannot be found, the rule is not
included in the route. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DegradedRoutes&rdquo; reason. The gateway
status for this route should be updated with a condition that describes
the error more specifically.</p>
<p>Support: custom</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteRule">HTTPRouteRule
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteSpec">HTTPRouteSpec</a>)
</p>
<p>
<p>HTTPRouteRule defines semantics for matching an incoming HTTP request against
a set of matching rules and executing an action (and optionally filters) on
the request.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>matches</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteMatch">
[]HTTPRouteMatch
</a>
</em>
</td>
<td>
<p>Matches define conditions used for matching the rule against
incoming HTTP requests.
Each match is independent, i.e. this rule will be matched
if <strong>any</strong> one of the matches is satisfied.</p>
<p>For example, take the following matches configuration:</p>
<pre><code>matches:
- path:
value: &quot;/foo&quot;
headers:
values:
version: &quot;2&quot;
- path:
value: &quot;/v2/foo&quot;
</code></pre>
<p>For a request to match against this rule, a request should satisfy
EITHER of the two conditions:</p>
<ul>
<li>path prefixed with <code>/foo</code> AND contains the header <code>version: &quot;2&quot;</code></li>
<li>path prefix of <code>/v2/foo</code></li>
</ul>
<p>See the documentation for HTTPRouteMatch on how to specify multiple
match conditions that should be ANDed together.</p>
<p>If no matches are specified, the default is a prefix
path match on &ldquo;/&rdquo;, which has the effect of matching every
HTTP request.</p>
</td>
</tr>
<tr>
<td>
<code>filters</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">
[]HTTPRouteFilter
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Filters define the filters that are applied to requests that match
this rule.</p>
<p>The effects of ordering of multiple behaviors are currently unspecified.
This can change in the future based on feedback during the alpha stage.</p>
<p>Conformance-levels at this level are defined based on the type of filter:
- ALL core filters MUST be supported by all implementations.
- Implementers are encouraged to support extended filters.
- Implementation-specific custom filters have no API guarantees across
implementations.</p>
<p>Specifying a core filter multiple times has unspecified or custom conformance.</p>
<p>Support: core</p>
</td>
</tr>
<tr>
<td>
<code>forwardTo</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteForwardTo">
[]HTTPRouteForwardTo
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ForwardTo defines the backend(s) where matching requests should be sent.
If unspecified, the rule performs no forwarding. If unspecified and no
filters are specified that would result in a response being sent, a 503
error code is returned.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteSpec">HTTPRouteSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRoute">HTTPRoute</a>)
</p>
<p>
<p>HTTPRouteSpec defines the desired state of HTTPRoute</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
<tr>
<td>
<code>hostnames</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Hostname">
[]Hostname
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Hostnames defines a set of hostname that should match against
the HTTP Host header to select a HTTPRoute to process the request.
Hostname is the fully qualified domain name of a network host,
as defined by RFC 3986. Note the following deviations from the
&ldquo;host&rdquo; part of the URI as defined in the RFC:</p>
<ol>
<li>IPs are not allowed.</li>
<li>The <code>:</code> delimiter is not respected because ports are not allowed.</li>
</ol>
<p>Incoming requests are matched against the hostnames before the
HTTPRoute rules. If no hostname is specified, traffic is routed
based on the HTTPRouteRules.</p>
<p>Hostname can be &ldquo;precise&rdquo; which is a domain name without the terminating
dot of a network host (e.g. &ldquo;foo.example.com&rdquo;) or &ldquo;wildcard&rdquo;, which is
a domain name prefixed with a single wildcard label (e.g. &ldquo;<em>.example.com&rdquo;).
The wildcard character &lsquo;</em>&rsquo; must appear by itself as the first DNS
label and matches only a single label.
You cannot have a wildcard label by itself (e.g. Host == &ldquo;</em>&rdquo;).
Requests will be matched against the Host field in the following order:
1. If Host is precise, the request matches this rule if
the http host header is equal to Host.
2. If Host is a wildcard, then the request matches this rule if
the http host header is to equal to the suffix
(removing the first label) of the wildcard rule.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteTLSConfig">
RouteTLSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS defines the TLS certificate to use for Hostnames defined in this
Route. This configuration only takes effect if the AllowRouteOverride
field is set to true in the associated Gateway resource.</p>
<p>Collisions can happen if multiple HTTPRoutes define a TLS certificate
for the same hostname. In such a case, conflict resolution guiding
principles apply, specificallly, if hostnames are same and two different
certificates are specified then the certificate in the
oldest resource wins.</p>
<p>Please note that HTTP Route-selection takes place after the
TLS Handshake (ClientHello). Due to this, TLS certificate defined
here will take precedence even if the request has the potential to
match multiple routes (in case multiple HTTPRoutes share the same
hostname).</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteRule">
[]HTTPRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of HTTP matchers, filters and actions.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HTTPRouteStatus">HTTPRouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRoute">HTTPRoute</a>)
</p>
<p>
<p>HTTPRouteStatus defines the observed state of HTTPRoute.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>RouteStatus</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.HeaderMatchType">HeaderMatchType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPHeaderMatch">HTTPHeaderMatch</a>)
</p>
<p>
<p>HeaderMatchType specifies the semantics of how HTTP header values should be
compared. Valid HeaderMatchType values are:</p>
<ul>
<li>&ldquo;Exact&rdquo;</li>
<li>&ldquo;RegularExpression&rdquo;</li>
<li>&ldquo;ImplementationSpecific&rdquo;</li>
</ul>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.Hostname">Hostname
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteSpec">HTTPRouteSpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.Listener">Listener</a>, 
<a href="#networking.x-k8s.io/v1alpha1.ListenerStatus">ListenerStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteMatch">TLSRouteMatch</a>)
</p>
<p>
<p>Hostname is used to specify a hostname that should be matched.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.Listener">Listener
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewaySpec">GatewaySpec</a>)
</p>
<p>
<p>Listener embodies the concept of a logical endpoint where a Gateway can
accept network connections. Each listener in a Gateway must have a unique
combination of Hostname, Port, and Protocol. This will be enforced by a
validating webhook.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>hostname</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Hostname">
Hostname
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Hostname specifies the virtual hostname to match for protocol types that
define this concept. When unspecified or &ldquo;<em>&rdquo;, all hostnames are matched.
This field can be omitted for protocols that don&rsquo;t require hostname based
matching.</p>
<p>Hostname is the fully qualified domain name of a network host, as defined
by RFC 3986. Note the following deviations from the &ldquo;host&rdquo; part of the
URI as defined in the RFC:</p>
<ol>
<li>IP literals are not allowed.</li>
<li>The <code>:</code> delimiter is not respected because ports are not allowed.</li>
</ol>
<p>Hostname can be &ldquo;precise&rdquo; which is a domain name without the terminating
dot of a network host (e.g. &ldquo;foo.example.com&rdquo;) or &ldquo;wildcard&rdquo;, which is a
domain name prefixed with a single wildcard label (e.g. &ldquo;<em>.example.com&rdquo;).
The wildcard character &lsquo;</em>&rsquo; must appear by itself as the first DNS label
and matches only a single label.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<p>Port is the network port. Multiple listeners may use the
same port, subject to the Listener compatibility rules.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>protocol</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.ProtocolType">
ProtocolType
</a>
</em>
</td>
<td>
<p>Protocol specifies the network protocol this listener expects to receive.
The GatewayClass MUST apply the Hostname match appropriately for each
protocol:</p>
<ul>
<li>For the &ldquo;TLS&rdquo; protocol, the Hostname match MUST be
applied to the <a href="https://tools.ietf.org/html/rfc6066#section-3">SNI</a>
server name offered by the client.</li>
<li>For the &ldquo;HTTP&rdquo; protocol, the Hostname match MUST be
applied to the host portion of the
<a href="https://tools.ietf.org/html/rfc7230#section-5.5">effective request URI</a>
or the <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.3">:authority pseudo-header</a></li>
<li>For the &ldquo;HTTPS&rdquo; protocol, the Hostname match MUST be
applied at both the TLS and HTTP protocol layers.</li>
</ul>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>tls</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayTLSConfig">
GatewayTLSConfig
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>TLS is the TLS configuration for the Listener. This field
is required if the Protocol field is &ldquo;HTTPS&rdquo; or &ldquo;TLS&rdquo; and
ignored otherwise.</p>
<p>The association of SNIs to Certificate defined in GatewayTLSConfig is
defined based on the Hostname field for this listener.</p>
<p>The GatewayClass MUST use the longest matching SNI out of all
available certificates for any TLS handshake.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>routes</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteBindingSelector">
RouteBindingSelector
</a>
</em>
</td>
<td>
<p>Routes specifies a schema for associating routes with the
Listener using selectors. A Route is a resource capable of
servicing a request and allows a cluster operator to expose
a cluster resource (i.e. Service) by externally-reachable
URL, load-balance traffic and terminate SSL/TLS.  Typically,
a route is a &ldquo;HTTPRoute&rdquo; or &ldquo;TCPRoute&rdquo; in group
&ldquo;networking.x-k8s.io&rdquo;, however, an implementation may support
other types of resources.</p>
<p>The Routes selector MUST select a set of objects that
are compatible with the application protocol specified in
the Protocol field.</p>
<p>Although a client request may technically match multiple route rules,
only one rule may ultimately receive the request. Matching precedence
MUST be determined in order of the following criteria:</p>
<ul>
<li>The most specific match. For example, the most specific HTTPRoute match
is determined by the longest matching combination of hostname and path.</li>
<li>The oldest Route based on creation timestamp. For example, a Route with
a creation timestamp of &ldquo;2020-09-08 01:02:03&rdquo; is given precedence over
a Route with a creation timestamp of &ldquo;2020-09-08 01:02:04&rdquo;.</li>
<li>If everything else is equivalent, the Route appearing first in
alphabetical order (namespace/name) should be given precedence. For
example, foo/bar is given precedence over foo/baz.</li>
</ul>
<p>All valid portions of a Route selected by this field should be supported.
Invalid portions of a Route can be ignored (sometimes that will mean the
full Route). If a portion of a Route transitions from valid to invalid,
support for that portion of the Route should be dropped to ensure
consistency. For example, even if a filter specified by a Route is
invalid, the rest of the Route should still be supported.</p>
<p>Support: Core</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.ListenerConditionReason">ListenerConditionReason
(<code>string</code> alias)</p></h3>
<p>
<p>ListenerConditionReason defines the set of reasons that explain
why a particular Listener condition type has been raised.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.ListenerConditionType">ListenerConditionType
(<code>string</code> alias)</p></h3>
<p>
<p>ListenerConditionType is a type of condition associated with the
listener. This type should be used with the ListenerStatus.Conditions
field.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.ListenerStatus">ListenerStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayStatus">GatewayStatus</a>)
</p>
<p>
<p>ListenerStatus is the status associated with a Listener.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<p>Port is the unique Listener port value for which this message is
reporting the status.</p>
</td>
</tr>
<tr>
<td>
<code>protocol</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.ProtocolType">
ProtocolType
</a>
</em>
</td>
<td>
<p>Protocol is the Listener protocol value for which this message is
reporting the status.</p>
</td>
</tr>
<tr>
<td>
<code>hostname</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Hostname">
Hostname
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Hostname is the Listener hostname value for which this message is
reporting the status.</p>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#condition-v1-meta">
[]Kubernetes meta/v1.Condition
</a>
</em>
</td>
<td>
<p>Conditions describe the current condition of this listener.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.LocalObjectReference">LocalObjectReference
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendTLSConfig">BackendTLSConfig</a>, 
<a href="#networking.x-k8s.io/v1alpha1.GatewayClassSpec">GatewayClassSpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.GatewayTLSConfig">GatewayTLSConfig</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRequestMirrorFilter">HTTPRequestMirrorFilter</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteFilter">HTTPRouteFilter</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteForwardTo">HTTPRouteForwardTo</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteMatch">HTTPRouteMatch</a>, 
<a href="#networking.x-k8s.io/v1alpha1.RouteForwardTo">RouteForwardTo</a>, 
<a href="#networking.x-k8s.io/v1alpha1.RouteTLSConfig">RouteTLSConfig</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteMatch">TCPRouteMatch</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteMatch">TLSRouteMatch</a>, 
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteMatch">UDPRouteMatch</a>)
</p>
<p>
<p>LocalObjectReference identifies an API object within a known namespace.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>group</code></br>
<em>
string
</em>
</td>
<td>
<p>Group is the group of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind is kind of the referent.</p>
</td>
</tr>
<tr>
<td>
<code>name</code></br>
<em>
string
</em>
</td>
<td>
<p>Name is the name of the referent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.PathMatchType">PathMatchType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPPathMatch">HTTPPathMatch</a>)
</p>
<p>
<p>PathMatchType specifies the semantics of how HTTP paths should be compared.
Valid PathMatchType values are:</p>
<ul>
<li>&ldquo;Exact&rdquo;</li>
<li>&ldquo;Prefix&rdquo;</li>
<li>&ldquo;RegularExpression&rdquo;</li>
<li>&ldquo;ImplementationSpecific&rdquo;</li>
</ul>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.PortNumber">PortNumber
(<code>int32</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.BackendRef">BackendRef</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRequestMirrorFilter">HTTPRequestMirrorFilter</a>, 
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteForwardTo">HTTPRouteForwardTo</a>, 
<a href="#networking.x-k8s.io/v1alpha1.Listener">Listener</a>, 
<a href="#networking.x-k8s.io/v1alpha1.ListenerStatus">ListenerStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.RouteForwardTo">RouteForwardTo</a>)
</p>
<p>
<p>PortNumber defines a network port.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.ProtocolType">ProtocolType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.Listener">Listener</a>, 
<a href="#networking.x-k8s.io/v1alpha1.ListenerStatus">ListenerStatus</a>)
</p>
<p>
<p>ProtocolType defines the application protocol accepted by a Listener.
Implementations are not required to accept all the defined protocols.
If an implementation does not support a specified protocol, it
should raise a &ldquo;Detached&rdquo; condition for the affected Listener with
a reason of &ldquo;UnsupportedProtocol&rdquo;.</p>
<p>Core ProtocolType values are:</p>
<ul>
<li>&ldquo;HTTP&rdquo;</li>
<li>&ldquo;HTTPS&rdquo;</li>
<li>&ldquo;TLS&rdquo;</li>
<li>&ldquo;TCP&rdquo;</li>
<li>&ldquo;UDP&rdquo;</li>
</ul>
<p>Implementations can define their own protocols if a core ProtocolType does not
exist. Such definitions must use prefixed name, such as
<code>mycompany.com/my-custom-protocol</code>. Un-prefixed names are reserved for core
protocols. Any protocol defined by implementations will fall under custom
conformance.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.RouteBindingSelector">RouteBindingSelector
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.Listener">Listener</a>)
</p>
<p>
<p>RouteBindingSelector defines a schema for associating routes with the Gateway.
If NamespaceSelector and RouteSelector are defined, only routes matching both
selectors are associated with the Gateway.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>namespaces</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteNamespaces">
RouteNamespaces
</a>
</em>
</td>
<td>
<p>Namespaces indicates in which namespaces Routes should be selected
for this Gateway. This is restricted to the namespace of this Gateway by
default.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>selector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Selector specifies a set of route labels used for selecting
routes to associate with the Gateway. If RouteSelector is defined,
only routes matching the RouteSelector are associated with the Gateway.
An empty RouteSelector matches all routes.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>group</code></br>
<em>
string
</em>
</td>
<td>
<p>Group is the group of the route resource to select. Omitting the value or specifying
the empty string indicates the networking.x-k8s.io API group.
For example, use the following to select an HTTPRoute:</p>
<p>routes:
kind: HTTPRoute</p>
<p>Otherwise, if an alternative API group is desired, specify the desired
group:</p>
<p>routes:
group: acme.io
kind: FooRoute</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>kind</code></br>
<em>
string
</em>
</td>
<td>
<p>Kind is the kind of the route resource to select.</p>
<p>Kind MUST correspond to kinds of routes that are compatible with the
application protocol specified in the Listener&rsquo;s Protocol field.</p>
<p>If an implementation does not support or recognize this
resource type, it SHOULD raise a &ldquo;ConditionInvalidRoutes&rdquo;
condition for the affected Listener.</p>
<p>Support: Core</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteConditionType">RouteConditionType
(<code>string</code> alias)</p></h3>
<p>
<p>RouteConditionType is a type of condition for a route.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.RouteForwardTo">RouteForwardTo
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteRule">TCPRouteRule</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteRule">TLSRouteRule</a>, 
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteRule">UDPRouteRule</a>)
</p>
<p>
<p>RouteForwardTo defines how a Route should forward a request.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>serviceName</code></br>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>ServiceName refers to the name of the Service to forward matched requests
to. When specified, this takes the place of BackendRef. If both
BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the rule is not included in the route.
The controller should raise the &ldquo;ResolvedRefs&rdquo; condition on the Gateway
with the &ldquo;DegradedRoutes&rdquo; reason. The gateway status for this route should
be updated with a condition that describes the error more specifically.</p>
<p>The protocol to use is defined using AppProtocol field (introduced in
Kubernetes 1.18) in the Service resource. In the absence of the
AppProtocol field a <code>networking.x-k8s.io/app-protocol</code> annotation on the
BackendPolicy resource may be used to define the protocol. If the
AppProtocol field is available, this annotation should not be used. The
AppProtocol field, when populated, takes precedence over the annotation
in the BackendPolicy resource. For custom backends, it is encouraged to
add a semantically-equivalent field in the Custom Resource Definition.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>backendRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>BackendRef is a reference to a backend to forward matched requests to. If
both BackendRef and ServiceName are specified, ServiceName will be given
precedence.</p>
<p>If the referent cannot be found, the rule is not included in the route.
The controller should raise the &ldquo;ResolvedRefs&rdquo; condition on the Gateway
with the &ldquo;DegradedRoutes&rdquo; reason. The gateway status for this route should
be updated with a condition that describes the error more specifically.</p>
<p>Support: Custom</p>
</td>
</tr>
<tr>
<td>
<code>port</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.PortNumber">
PortNumber
</a>
</em>
</td>
<td>
<p>Port specifies the destination port number to use for the
backend referenced by the ServiceName or BackendRef field.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>weight</code></br>
<em>
int32
</em>
</td>
<td>
<p>Weight specifies the proportion of HTTP requests forwarded to the backend
referenced by the ServiceName or BackendRef field. This is computed as
weight/(sum of all weights in this ForwardTo list). For non-zero values,
there may be some epsilon from the exact proportion defined here
depending on the precision an implementation supports. Weight is not a
percentage and the sum of weights does not need to equal 100.</p>
<p>If only one backend is specified and it has a weight greater than 0, 100%
of the traffic is forwarded to that backend. If weight is set to 0, no
traffic should be forwarded for this entry. If unspecified, weight
defaults to 1.</p>
<p>Support: Extended</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteGatewayStatus">RouteGatewayStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.RouteStatus">RouteStatus</a>)
</p>
<p>
<p>RouteGatewayStatus describes the status of a route with respect to an
associated Gateway.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>gatewayRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayReference">
GatewayReference
</a>
</em>
</td>
<td>
<p>GatewayRef is a reference to a Gateway object that is associated with
the route.</p>
</td>
</tr>
<tr>
<td>
<code>conditions</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#condition-v1-meta">
[]Kubernetes meta/v1.Condition
</a>
</em>
</td>
<td>
<p>Conditions describes the status of the route with respect to the
Gateway.  For example, the &ldquo;Admitted&rdquo; condition indicates whether the
route has been admitted or rejected by the Gateway, and why.  Note
that the route&rsquo;s availability is also subject to the Gateway&rsquo;s own
status conditions and listener status.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteGateways">RouteGateways
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteSpec">HTTPRouteSpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteSpec">TCPRouteSpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteSpec">TLSRouteSpec</a>, 
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteSpec">UDPRouteSpec</a>)
</p>
<p>
<p>RouteGateways defines which Gateways will be able to use a route. If this
field results in preventing the selection of a Route by a Gateway, an
&ldquo;Admitted&rdquo; condition with a status of false must be set for the Gateway on
that Route.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>allow</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayAllowType">
GatewayAllowType
</a>
</em>
</td>
<td>
<p>Allow indicates which Gateways will be allowed to use this route.
Possible values are:
* All: Gateways in any namespace can use this route.
* FromList: Only Gateways specified in GatewayRefs may use this route.
* SameNamespace: Only Gateways in the same namespace may use this route.</p>
</td>
</tr>
<tr>
<td>
<code>gatewayRefs</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayReference">
[]GatewayReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>GatewayRefs must be specified when Allow is set to &ldquo;FromList&rdquo;. In that
case, only Gateways referenced in this list will be allowed to use this
route. This field is ignored for other values of &ldquo;Allow&rdquo;.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteNamespaces">RouteNamespaces
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.RouteBindingSelector">RouteBindingSelector</a>)
</p>
<p>
<p>RouteNamespaces indicate which namespaces Routes should be selected from.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>from</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteSelectType">
RouteSelectType
</a>
</em>
</td>
<td>
<p>From indicates where Routes will be selected for this Gateway. Possible
values are:
* All: Routes in all namespaces may be used by this Gateway.
* Selector: Routes in namespaces selected by the selector may be used by
this Gateway.
* Same: Only Routes in the same namespace may be used by this Gateway.</p>
<p>Support: Core</p>
</td>
</tr>
<tr>
<td>
<code>selector</code></br>
<em>
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Selector must be specified when From is set to &ldquo;Selector&rdquo;. In that case,
only Routes in Namespaces matching this Selector will be selected by this
Gateway. This field is ignored for other values of &ldquo;From&rdquo;.</p>
<p>Support: Core</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteSelectType">RouteSelectType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.RouteNamespaces">RouteNamespaces</a>)
</p>
<p>
<p>RouteSelectType specifies where Routes should be selected by a Gateway.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.RouteStatus">RouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteStatus">HTTPRouteStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteStatus">TCPRouteStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteStatus">TLSRouteStatus</a>, 
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteStatus">UDPRouteStatus</a>)
</p>
<p>
<p>RouteStatus defines the observed state that is required across
all route types.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGatewayStatus">
[]RouteGatewayStatus
</a>
</em>
</td>
<td>
<p>Gateways is a list of the Gateways that are associated with the
route, and the status of the route with respect to each of these
Gateways. When a Gateway selects this route, the controller that
manages the Gateway should add an entry to this list when the
controller first sees the route and should update the entry as
appropriate when the route is modified.</p>
<p>A maximum of 100 Gateways will be represented in this list. If this list
is full, there may be additional Gateways using this Route that are not
included in the list.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.RouteTLSConfig">RouteTLSConfig
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.HTTPRouteSpec">HTTPRouteSpec</a>)
</p>
<p>
<p>RouteTLSConfig describes a TLS configuration defined at the Route level.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>certificateRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<p>CertificateRef refers to a Kubernetes object that
contains a TLS certificate and private key.
This certificate MUST be used for TLS handshakes for the domain
this RouteTLSConfig is associated with.
If an entry in this list omits or specifies the empty
string for both the group and the resource, the resource defaults to &ldquo;secrets&rdquo;.
An implementation may support other resources (for example, resource
&ldquo;mycertificates&rdquo; in group &ldquo;networking.acme.io&rdquo;).
Support: Core (Kubernetes Secrets)
Support: Implementation-specific (Other resource types)</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TCPRouteMatch">TCPRouteMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteRule">TCPRouteRule</a>)
</p>
<p>
<p>TCPRouteMatch defines the predicate used to match connections to a
given action.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>extensionRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ExtensionRef is an optional, implementation-specific extension to the
&ldquo;match&rdquo; behavior.  For example, resource &ldquo;mytcproutematcher&rdquo; in group
&ldquo;networking.acme.io&rdquo;. If the referent cannot be found, the rule is not
included in the route. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DegradedRoutes&rdquo; reason. The gateway
status for this route should be updated with a condition that describes
the error more specifically.</p>
<p>Support: custom</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TCPRouteRule">TCPRouteRule
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteSpec">TCPRouteSpec</a>)
</p>
<p>
<p>TCPRouteRule is the configuration for a given rule.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>matches</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteMatch">
[]TCPRouteMatch
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Matches define conditions used for matching the rule against
incoming TCP connections. Each match is independent, i.e. this
rule will be matched if <strong>any</strong> one of the matches is satisfied.
If unspecified, all requests from the associated gateway TCP
listener will match.</p>
</td>
</tr>
<tr>
<td>
<code>forwardTo</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteForwardTo">
[]RouteForwardTo
</a>
</em>
</td>
<td>
<p>ForwardTo defines the backend(s) where matching requests should
be sent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TCPRouteSpec">TCPRouteSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRoute">TCPRoute</a>)
</p>
<p>
<p>TCPRouteSpec defines the desired state of TCPRoute</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRouteRule">
[]TCPRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of TCP matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TCPRouteStatus">TCPRouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TCPRoute">TCPRoute</a>)
</p>
<p>
<p>TCPRouteStatus defines the observed state of TCPRoute</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>RouteStatus</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSModeType">TLSModeType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayTLSConfig">GatewayTLSConfig</a>)
</p>
<p>
<p>TLSModeType type defines behavior of gateway with TLS protocol.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.TLSOverridePolicy">TLSOverridePolicy
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.GatewayTLSConfig">GatewayTLSConfig</a>)
</p>
<p>
<p>TLSOverridePolicy defines a schema for overriding TLS settings at the Route
level.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>certificate</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteOverrideType">
TLSRouteOverrideType
</a>
</em>
</td>
<td>
<p>Certificate dictates if TLS certificates can be configured
via Routes. If set to &lsquo;Allow&rsquo;, a TLS certificate for a hostname
defined in a Route takes precedence over the certificate defined in
Gateway.</p>
<p>Support: Core</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRouteMatch">TLSRouteMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteRule">TLSRouteRule</a>)
</p>
<p>
<p>TLSRouteMatch defines the predicate used to match connections to a
given action.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>snis</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.Hostname">
[]Hostname
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>SNIs defines a set of SNI names that should match against the
SNI attribute of TLS ClientHello message in TLS handshake.</p>
<p>SNI can be &ldquo;precise&rdquo; which is a domain name without the terminating
dot of a network host (e.g. &ldquo;foo.example.com&rdquo;) or &ldquo;wildcard&rdquo;, which is
a domain name prefixed with a single wildcard label (e.g. &ldquo;<em>.example.com&rdquo;).
The wildcard character &lsquo;</em>&rsquo; must appear by itself as the first DNS label
and matches only a single label. You cannot have a wildcard label by
itself (e.g. Host == &ldquo;</em>&rdquo;).</p>
<p>Requests will be matched against the Host field in the following order:</p>
<ol>
<li>If SNI is precise, the request matches this rule if the SNI in
ClientHello is equal to one of the defined SNIs.</li>
<li>If SNI is a wildcard, then the request matches this rule if the
SNI is to equal to the suffix (removing the first label) of the
wildcard rule.</li>
<li>If SNIs is unspecified, all requests associated with the gateway TLS
listener will match. This can be used to define a default backend
for a TLS listener.</li>
</ol>
<p>Support: core</p>
</td>
</tr>
<tr>
<td>
<code>extensionRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ExtensionRef is an optional, implementation-specific extension to the
&ldquo;match&rdquo; behavior.  For example, resource &ldquo;mytlsroutematcher&rdquo; in group
&ldquo;networking.acme.io&rdquo;. If the referent cannot be found, the rule is not
included in the route. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DegradedRoutes&rdquo; reason. The gateway
status for this route should be updated with a condition that describes
the error more specifically.</p>
<p>Support: custom</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRouteOverrideType">TLSRouteOverrideType
(<code>string</code> alias)</p></h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TLSOverridePolicy">TLSOverridePolicy</a>)
</p>
<p>
<p>TLSRouteOverrideType type defines the level of allowance for Routes
to override a specific TLS setting.</p>
</p>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRouteRule">TLSRouteRule
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteSpec">TLSRouteSpec</a>)
</p>
<p>
<p>TLSRouteRule is the configuration for a given rule.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>matches</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteMatch">
[]TLSRouteMatch
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Matches define conditions used for matching the rule against an
incoming TLS handshake. Each match is independent, i.e. this
rule will be matched if <strong>any</strong> one of the matches is satisfied.
If unspecified, all requests from the associated gateway TLS
listener will match.</p>
</td>
</tr>
<tr>
<td>
<code>forwardTo</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteForwardTo">
[]RouteForwardTo
</a>
</em>
</td>
<td>
<p>ForwardTo defines the backend(s) where matching requests should be
sent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRouteSpec">TLSRouteSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRoute">TLSRoute</a>)
</p>
<p>
<p>TLSRouteSpec defines the desired state of TLSRoute</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRouteRule">
[]TLSRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of TLS matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.TLSRouteStatus">TLSRouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.TLSRoute">TLSRoute</a>)
</p>
<p>
<p>TLSRouteStatus defines the observed state of TLSRoute</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>RouteStatus</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.UDPRouteMatch">UDPRouteMatch
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteRule">UDPRouteRule</a>)
</p>
<p>
<p>UDPRouteMatch defines the predicate used to match packets to a
given action.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>extensionRef</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.LocalObjectReference">
LocalObjectReference
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>ExtensionRef is an optional, implementation-specific extension to the
&ldquo;match&rdquo; behavior.  For example, resource &ldquo;myudproutematcher&rdquo; in group
&ldquo;networking.acme.io&rdquo;. If the referent cannot be found, the rule is not
included in the route. The controller should raise the &ldquo;ResolvedRefs&rdquo;
condition on the Gateway with the &ldquo;DegradedRoutes&rdquo; reason. The gateway
status for this route should be updated with a condition that describes
the error more specifically.</p>
<p>Support: custom</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.UDPRouteRule">UDPRouteRule
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteSpec">UDPRouteSpec</a>)
</p>
<p>
<p>UDPRouteRule is the configuration for a given rule.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>matches</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteMatch">
[]UDPRouteMatch
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>Matches define conditions used for matching the rule against
incoming UDP connections. Each match is independent, i.e. this
rule will be matched if <strong>any</strong> one of the matches is satisfied.
If unspecified, all requests from the associated gateway UDP
listener will match.</p>
</td>
</tr>
<tr>
<td>
<code>forwardTo</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteForwardTo">
[]RouteForwardTo
</a>
</em>
</td>
<td>
<p>ForwardTo defines the backend(s) where matching requests should
be sent.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.UDPRouteSpec">UDPRouteSpec
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRoute">UDPRoute</a>)
</p>
<p>
<p>UDPRouteSpec defines the desired state of UDPRoute.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>rules</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRouteRule">
[]UDPRouteRule
</a>
</em>
</td>
<td>
<p>Rules are a list of UDP matchers and actions.</p>
</td>
</tr>
<tr>
<td>
<code>gateways</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteGateways">
RouteGateways
</a>
</em>
</td>
<td>
<p>Gateways defines which Gateways can use this Route.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="networking.x-k8s.io/v1alpha1.UDPRouteStatus">UDPRouteStatus
</h3>
<p>
(<em>Appears on:</em>
<a href="#networking.x-k8s.io/v1alpha1.UDPRoute">UDPRoute</a>)
</p>
<p>
<p>UDPRouteStatus defines the observed state of UDPRoute.</p>
</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>RouteStatus</code></br>
<em>
<a href="#networking.x-k8s.io/v1alpha1.RouteStatus">
RouteStatus
</a>
</em>
</td>
<td>
<p>
(Members of <code>RouteStatus</code> are embedded into this type.)
</p>
</td>
</tr>
</tbody>
</table>
<hr/>
<p><em>
Generated with <code>gen-crd-api-reference-docs</code>.
</em></p></p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../tls/" title="TLS" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                TLS
              </span>
            </div>
          </a>
        
        
          <a href="../releases/" title="Releases" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Releases
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.808e90bb.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
  </body>
</html>