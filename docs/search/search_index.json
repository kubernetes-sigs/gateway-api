{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This is the documentation for the evolution of service-related APIs for Kubernetes. This project is part of the Kubernetes project working under SIG-NETWORK . Gateway API Gateway is an API for a common portable declarative description of load-balancing infrastructure for Kubernetes. If you are a user: User guide (how to use the API) Cookbook for common tasks If you are a developer: How to build and test How to contribute, meetings, design docs For everyone: Concepts and detailed descriptions API specification Releases Security Model Design Decisions Enhancement requests Feedback and bug reports Contacts Slack: #sig-network-service-apis Project Owners","title":"Introduction"},{"location":"#introduction","text":"This is the documentation for the evolution of service-related APIs for Kubernetes. This project is part of the Kubernetes project working under SIG-NETWORK .","title":"Introduction"},{"location":"#gateway-api","text":"Gateway is an API for a common portable declarative description of load-balancing infrastructure for Kubernetes. If you are a user: User guide (how to use the API) Cookbook for common tasks If you are a developer: How to build and test How to contribute, meetings, design docs For everyone: Concepts and detailed descriptions API specification Releases Security Model Design Decisions Enhancement requests Feedback and bug reports","title":"Gateway API"},{"location":"#contacts","text":"Slack: #sig-network-service-apis Project Owners","title":"Contacts"},{"location":"community/","text":"How to contribute This page contains links to all of the meeting notes, design docs and related discussions around the APIs. Communications Major discussions and notifications will be sent on the SIG-NETWORK mailing list . We also have a Slack channel (sig-network-service-apis) on k8s.io for day-to-day questions, discussions. Meetings Meetings discussing the evolution of the service APIs will alternate times to accommodate participants from various time zones. This calendar includes all Service APIs meetings as well as any other SIG-Network meetings. Thursday 10:30 AM Pacific (EMEA Friendly Time) [Zoom Link] Thursday 4:30 (16:30) PM Pacific (APAC Friendly Time) Office Hours In addition to weekly meetings, we have informal weekly office hours meetings on Wednesdays. Wednesday 3:00 (15:00) PM Pacific Meeting notes Meeting schedule scratch pad Meeting recordings . Date Future meetings Check the calendar February 27, 2019 meeting notes , recording February 20, 2019 meeting notes , recording February 13, 2019 meeting notes , recording February 6, 2019 meeting notes , recording January 30, 2019 meeting notes , recording January 23, 2019 meeting notes , recording TODO January 16, 2019 meeting notes , recording January 9, 2019 meeting notes , recording January 2, 2020 meeting notes , recording didn't work :-( look at the notes December 19, 2019 meeting notes , recording November, 2019 Kubecon 2019 San Diego: API evolution design discussion November, 2019 SIG-NETWORK: Ingress Evolution Sync May, 2019 Kubecon 2019 Barcelona: SIG-NETWORK discussion (general topics, includes V2) Design docs Title Description API sketch Sketch of the proposed API Presentations, Talks Date Title November, 2019 Kubecon 2019 San Diego: Evolving the Kubernetes Ingress APIs to GA and Beyond slides , video November, 2019 Kubecon 2019 San Diego: SIG-NETWORK Service/Ingress Evolution Discussion slides May, 2019 Kubecon 2019 Barcelona: Ingress V2 and Multicluster Services slides , video March, 2018 SIG-NETWORK: Ingress user survey data , slides Code of conduct Participation in the Kubernetes community is governed by the Kubernetes Code of Conduct","title":"How to contribute"},{"location":"community/#how-to-contribute","text":"This page contains links to all of the meeting notes, design docs and related discussions around the APIs.","title":"How to contribute"},{"location":"community/#communications","text":"Major discussions and notifications will be sent on the SIG-NETWORK mailing list . We also have a Slack channel (sig-network-service-apis) on k8s.io for day-to-day questions, discussions.","title":"Communications"},{"location":"community/#meetings","text":"Meetings discussing the evolution of the service APIs will alternate times to accommodate participants from various time zones. This calendar includes all Service APIs meetings as well as any other SIG-Network meetings. Thursday 10:30 AM Pacific (EMEA Friendly Time) [Zoom Link] Thursday 4:30 (16:30) PM Pacific (APAC Friendly Time)","title":"Meetings"},{"location":"community/#office-hours","text":"In addition to weekly meetings, we have informal weekly office hours meetings on Wednesdays. Wednesday 3:00 (15:00) PM Pacific","title":"Office Hours"},{"location":"community/#meeting-notes","text":"Meeting schedule scratch pad Meeting recordings . Date Future meetings Check the calendar February 27, 2019 meeting notes , recording February 20, 2019 meeting notes , recording February 13, 2019 meeting notes , recording February 6, 2019 meeting notes , recording January 30, 2019 meeting notes , recording January 23, 2019 meeting notes , recording TODO January 16, 2019 meeting notes , recording January 9, 2019 meeting notes , recording January 2, 2020 meeting notes , recording didn't work :-( look at the notes December 19, 2019 meeting notes , recording November, 2019 Kubecon 2019 San Diego: API evolution design discussion November, 2019 SIG-NETWORK: Ingress Evolution Sync May, 2019 Kubecon 2019 Barcelona: SIG-NETWORK discussion (general topics, includes V2)","title":"Meeting notes"},{"location":"community/#design-docs","text":"Title Description API sketch Sketch of the proposed API","title":"Design docs"},{"location":"community/#presentations-talks","text":"Date Title November, 2019 Kubecon 2019 San Diego: Evolving the Kubernetes Ingress APIs to GA and Beyond slides , video November, 2019 Kubecon 2019 San Diego: SIG-NETWORK Service/Ingress Evolution Discussion slides May, 2019 Kubecon 2019 Barcelona: Ingress V2 and Multicluster Services slides , video March, 2018 SIG-NETWORK: Ingress user survey data , slides","title":"Presentations, Talks"},{"location":"community/#code-of-conduct","text":"Participation in the Kubernetes community is governed by the Kubernetes Code of Conduct","title":"Code of conduct"},{"location":"concepts/","text":"API Concepts This document is a deep dive into the reasoning and design for the API. The content of this document was originally taken from the API sketch . We will try to keep the two documents in sync as the sketch document has to lowest bar to contribution, but this document is easier to format well and review. Roles and personas In the original design of Kubernetes, the Ingress and Service resources were based on a self-service model of usage; developers who create Services and Ingresses control all aspects of defining and exposing their applications to their users. We have found that the self-service model does not fully capture some of the more complex deployment and team structures that our users are seeing. The Gateway/Routes API will target the following personas: Infrastructure provider : The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include public cloud providers (AWS, Azure, GCP, ...), or PaaS providers within an organization. Cluster operator : The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, and application permissions. Application developer : The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends). We expect that each persona will map approximately to a Role in the Kubernetes Role-Based Authentication (RBAC) system and will define resource model responsibility and separation. Depending on the environment, multiple roles can map to the same user. For example, giving the user all of the above role replicates the self-service model. For more information on the roles and personas considered in the Service API design, refer to the Security Model . Resource model Note: Resource will initially live in the networking.x-k8s.io API group as Custom Resource Definitions (CRDs). Unqualified resource names will implicitly be assumed to be part of this API group. There are three main types of object in our resource model: GatewayClass defines a set of gateways with a common configuration and behavior. Gateway requests a point where traffic can be translated to Services within the cluster. Routes describe how traffic coming via the Gateway maps to the Services. GatewayClass GatewayClass defines a set of Gateways that share a common configuration and behaviour. Each GatewayClass will be handled by a single controller, although controllers MAY handle more than one. GatewayClass is a cluster-scoped resource. There MUST be at least one GatewayClass defined in order to be able to have functional Gateways. A controller that implements the Gateway API does so by providing an associated GatewayClass resource that the user can reference from their Gateway(s). This is similar to IngressClass for Ingress and StorageClass for PersistentVolumes. In Ingress v1beta1, the closest analog to GatewayClass is the ingress-class annotation, and in IngressV1, the closest analog is the IngressClass object. Gateway A Gateway describes how traffic can be translated to Services within the cluster. That is, it defines a request for a way to translate traffic from somewhere that does not know about Kubernetes to somewhere that does. For example, traffic sent to a Kubernetes Services by a cloud load balancer, an in-cluster proxy or external hardware load balancer. While many use cases have client traffic originating \u201coutside\u201d the cluster, this is not a requirement. It defines a request for a specific load balancer config that implements the GatewayClass\u2019 configuration and behaviour contract. The resource MAY be created by an operator directly, or MAY be created by a controller handling a GatewayClass. As the Gateway spec captures user intent, it may not contain a complete specification for all attributes in the spec. For example, the user may omit fields such as addresses, ports, TLS settings. This allows the controller managing the GatewayClass to provide these settings for the user, resulting in a more portable spec. This behaviour will be made clear using the GatewayClass Status object. A Gateway MAY contain one or more *Route references which serve to direct traffic for a subset of traffic to a specific service. {HTTP,TCP,Foo}Route Various types of Route objects define how traffic via the Gateway is mapped to Kubernetes Services. Currently the two Route object types are HTTPRoute and TCPRoute , to cover the two most common uses for this sort of traffic. This design is intended to be extensible at this point - it is possible that the service-apis team may create a UDPRoute, or even an IPRoute in the future. Combined types The combination of GatewayClass , Gateway , xxxxRoute and Service (s) will define an implementable load-balancer. The diagram below illustrates the relationships between the different resources: Request flow A typical client/gateway API request flow for a gateway implemented using a reverse proxy is: A client makes a request to a FQDN, i.e. \"foo.example.com\". The FQDN gets resolved to gateway.status.listeners[x].address . The request is received by the Gateway implementation, i.e. reverse proxy, on gateway.status.listeners[x].address and gateway.spec.listeners[x].port . If the request uses TLS, then gateway.spec.listeners[x].tls is used for establishing the connection. Note: The details for modeling a \"virtual host\" is still under review . Therefore, how TLS is configured may change in the future. If the Gateway is configured to terminate the TLS connection, an HTTPRoute is selected based on the request\u2019s Host header , i.e. FQDN in step 1, matching httpRoute.spec.hosts[x].hostname . If the Gateway is configured to pass the TLS connection through to the backend object, i.e. Service, SNI is used to match the request with an HTTPRoute based on httpRoute.spec.hosts[x].hostname . Note: Whether hosts should be singular is still under review . The Gateway implementation performs filtering (optional) and forwarding based on httpRoute.spec.hosts[x].rules[x].match . The match can be based on the request path and/or header. Lastly, the request is forwarded to an object within the cluster. TLS Configuration TLS configuration is tied to Gateway listeners. Although adding the option to configure TLS on other resources was considered, ultimately TLS configuration on Gateway listeners was deemed sufficient for the following reasons: In most cases, users that are configuring TLS will naturally also have access to Gateways. In other cases, TLS config could be implemented with a controller watching Routes and adding generated certs to corresponding Gateways. This does not solve the use case for users wanting to provide their own certs for Routes while not having access to a Gateway resource. This seems like it would be a rare edge case and is not worth supporting at this point. The security model outlined a potential approach to enable this in the future, but there does not seem to be a sufficient reason to work towards that now. Design considerations There are some general design guidelines used throughout this API. Single resource consistency The Kubernetes API guarantees consistency only on a single resource level. There are a couple of consequences for complex resource graphs as opposed to single resources: Error checking of properties spanning multiple resource will be asynchronous and eventually consistent. Simple syntax checks will be possible at the single resource level, but cross resource dependencies will need to be handled by the controller. Controllers will need to handle broken links between resources and/or mismatched configuration. Conflicts Separation and delegation of responsibility among independent actors (e.g between cluster ops and application developers) can result in conflicts in the configuration. For example, two application teams may inadvertently submit configuration for the same HTTP path. There are several different strategies for handling this: TODO Extensibility TODO GatewayClass GatewayClass ( source code ) is cluster-scoped resource defined by the infrastructure provider. This resource represents a class of Gateways that can be instantiated. Note: this serves the same function as the networking.IngressClass resource . kind: GatewayClass metadata: name: cluster-gateway spec: controller: \"acme.io/gateway-controller\" We expect that one or more GatewayClasses will be created by the infrastructure provider for the user. It allows decoupling of which mechanism (e.g. controller) implements the Gateways from the user. For instance, an infrastructure provider may create two GatewayClasses named internet and private to reflect Gateways that define Internet-facing vs private, internal applications. kind: GatewayClass metadata: name: internet ... --- kind: GatewayClass metadata: name: private ... The user of the classes will not need to know how internet and private are implemented. Instead, the user will only need to understand the resulting properties of the class that the Gateway was created with. GatewayClass parameters Providers of the Gateway API may need to pass parameters to their controller as part of the class definition. This is done using the GatewayClass.spec.parametersRef field: # GatewayClass for Gateways that define Internet-facing applications. kind: GatewayClass metadata: name: internet spec: controller: \"acme.io/gateway-controller\" parametersRef: apiVersion: core/v1 kind: ConfigMap namespace: acme-system name: internet-gateway --- kind: ConfigMap metadata: name: internet-gateway namespace: acme-system data: ip-address-pool: internet-vips ... The type of object referenced by GatewayClass.spec.parametersRef will depend on the provider itself. A core.ConfigMap is used in the example above, but controllers may opt to use a CustomResource for better schema validation. GatewayClass status GatewayClasses MUST be validated by the provider to ensure that the configured parameters are valid. The validity of the class will be signaled to the user via GatewayClass.status : kind: GatewayClass ... status: conditions: - type: InvalidParameters status: Unknown ... A new GatewayClass will start with the InvalidParameters condition set to Unknown . At this point the controller has not seen the configuration. Once the controller has processed the configuration, the condition will be set to False : kind: GatewayClass ... status: conditions: - type: InvalidParameters status: False ... If there is an error in the GatewayClass.spec , the conditions will be non-empty and contain information about the error. kind: GatewayClass ... status: conditions: - type: InvalidParameters status: True Reason: BadFooBar Message: \"foobar\" is an FooBar. Gateway A Gateway is 1:1 with the life cycle of the configuration of infrastructure. When a user creates a Gateway , some load balancing infrastructure is provisioned or configured (see below for details) by the GatewayClass controller. Gateway is the resource that triggers actions in this API. Other resources in this API are configuration snippets until a Gateway has been created to link the resources together. The Gateway spec defines the following: The GatewayClass used to instantiate this Gateway. The Listener bindings, which define addresses and ports, protocol termination, and TLS settings. The Listener configuration requested by a Gateway definition can be incompatible with a given GatewayClass (e.g. port/protocol combination is not supported). The Routes, which describe how traffic is processed and forwarded. If the Listener configuration requested by a Gateway definition is incompatible with a given GatewayClass, the Gateway will be in an error state, signaled by the status field. Deployment models Depending on the GatewayClass , the creation of the Gateway could do any of the following actions: Use cloud APIs to create an LB instance. Spawn a new instance of a software LB (in this or another cluster). Add a configuration stanza to an already instantiated LB to handle the new routes. Program the SDN to implement the configuration. Something else we haven\u2019t thought of yet... The API does not specify which one of these actions will be taken. Note that a GatewayClass controller that manages in-cluster proxy processes MAY restrict Gateway configuration scope, e.g. only be served in the same namespace. Gateway Status Gateways track status for the Gateway resource as a whole as well as each Listener it contains. The status for a specific Route is reported in the status of the Route resource. Within GatewayStatus , Listeners will have status entries corresponding to their name. Both GatewayStatus and ListenerStatus follow the conditions pattern used elsewhere in Kubernetes. This is a list that includes a type of condition, the status of that condition, and the last time this condition changed. Listeners TODO Routes TODO HTTPRoute TODO TCPRoute TODO Generic routing TODO Delegation/inclusion TODO Destinations TODO","title":"API concepts"},{"location":"concepts/#api-concepts","text":"This document is a deep dive into the reasoning and design for the API. The content of this document was originally taken from the API sketch . We will try to keep the two documents in sync as the sketch document has to lowest bar to contribution, but this document is easier to format well and review.","title":"API Concepts"},{"location":"concepts/#roles-and-personas","text":"In the original design of Kubernetes, the Ingress and Service resources were based on a self-service model of usage; developers who create Services and Ingresses control all aspects of defining and exposing their applications to their users. We have found that the self-service model does not fully capture some of the more complex deployment and team structures that our users are seeing. The Gateway/Routes API will target the following personas: Infrastructure provider : The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include public cloud providers (AWS, Azure, GCP, ...), or PaaS providers within an organization. Cluster operator : The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, and application permissions. Application developer : The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends). We expect that each persona will map approximately to a Role in the Kubernetes Role-Based Authentication (RBAC) system and will define resource model responsibility and separation. Depending on the environment, multiple roles can map to the same user. For example, giving the user all of the above role replicates the self-service model. For more information on the roles and personas considered in the Service API design, refer to the Security Model .","title":"Roles and personas"},{"location":"concepts/#resource-model","text":"Note: Resource will initially live in the networking.x-k8s.io API group as Custom Resource Definitions (CRDs). Unqualified resource names will implicitly be assumed to be part of this API group. There are three main types of object in our resource model: GatewayClass defines a set of gateways with a common configuration and behavior. Gateway requests a point where traffic can be translated to Services within the cluster. Routes describe how traffic coming via the Gateway maps to the Services.","title":"Resource model"},{"location":"concepts/#gatewayclass","text":"GatewayClass defines a set of Gateways that share a common configuration and behaviour. Each GatewayClass will be handled by a single controller, although controllers MAY handle more than one. GatewayClass is a cluster-scoped resource. There MUST be at least one GatewayClass defined in order to be able to have functional Gateways. A controller that implements the Gateway API does so by providing an associated GatewayClass resource that the user can reference from their Gateway(s). This is similar to IngressClass for Ingress and StorageClass for PersistentVolumes. In Ingress v1beta1, the closest analog to GatewayClass is the ingress-class annotation, and in IngressV1, the closest analog is the IngressClass object.","title":"GatewayClass"},{"location":"concepts/#gateway","text":"A Gateway describes how traffic can be translated to Services within the cluster. That is, it defines a request for a way to translate traffic from somewhere that does not know about Kubernetes to somewhere that does. For example, traffic sent to a Kubernetes Services by a cloud load balancer, an in-cluster proxy or external hardware load balancer. While many use cases have client traffic originating \u201coutside\u201d the cluster, this is not a requirement. It defines a request for a specific load balancer config that implements the GatewayClass\u2019 configuration and behaviour contract. The resource MAY be created by an operator directly, or MAY be created by a controller handling a GatewayClass. As the Gateway spec captures user intent, it may not contain a complete specification for all attributes in the spec. For example, the user may omit fields such as addresses, ports, TLS settings. This allows the controller managing the GatewayClass to provide these settings for the user, resulting in a more portable spec. This behaviour will be made clear using the GatewayClass Status object. A Gateway MAY contain one or more *Route references which serve to direct traffic for a subset of traffic to a specific service.","title":"Gateway"},{"location":"concepts/#httptcpfooroute","text":"Various types of Route objects define how traffic via the Gateway is mapped to Kubernetes Services. Currently the two Route object types are HTTPRoute and TCPRoute , to cover the two most common uses for this sort of traffic. This design is intended to be extensible at this point - it is possible that the service-apis team may create a UDPRoute, or even an IPRoute in the future.","title":"{HTTP,TCP,Foo}Route"},{"location":"concepts/#combined-types","text":"The combination of GatewayClass , Gateway , xxxxRoute and Service (s) will define an implementable load-balancer. The diagram below illustrates the relationships between the different resources:","title":"Combined types"},{"location":"concepts/#request-flow","text":"A typical client/gateway API request flow for a gateway implemented using a reverse proxy is: A client makes a request to a FQDN, i.e. \"foo.example.com\". The FQDN gets resolved to gateway.status.listeners[x].address . The request is received by the Gateway implementation, i.e. reverse proxy, on gateway.status.listeners[x].address and gateway.spec.listeners[x].port . If the request uses TLS, then gateway.spec.listeners[x].tls is used for establishing the connection. Note: The details for modeling a \"virtual host\" is still under review . Therefore, how TLS is configured may change in the future. If the Gateway is configured to terminate the TLS connection, an HTTPRoute is selected based on the request\u2019s Host header , i.e. FQDN in step 1, matching httpRoute.spec.hosts[x].hostname . If the Gateway is configured to pass the TLS connection through to the backend object, i.e. Service, SNI is used to match the request with an HTTPRoute based on httpRoute.spec.hosts[x].hostname . Note: Whether hosts should be singular is still under review . The Gateway implementation performs filtering (optional) and forwarding based on httpRoute.spec.hosts[x].rules[x].match . The match can be based on the request path and/or header. Lastly, the request is forwarded to an object within the cluster.","title":"Request flow"},{"location":"concepts/#tls-configuration","text":"TLS configuration is tied to Gateway listeners. Although adding the option to configure TLS on other resources was considered, ultimately TLS configuration on Gateway listeners was deemed sufficient for the following reasons: In most cases, users that are configuring TLS will naturally also have access to Gateways. In other cases, TLS config could be implemented with a controller watching Routes and adding generated certs to corresponding Gateways. This does not solve the use case for users wanting to provide their own certs for Routes while not having access to a Gateway resource. This seems like it would be a rare edge case and is not worth supporting at this point. The security model outlined a potential approach to enable this in the future, but there does not seem to be a sufficient reason to work towards that now.","title":"TLS Configuration"},{"location":"concepts/#design-considerations","text":"There are some general design guidelines used throughout this API.","title":"Design considerations"},{"location":"concepts/#single-resource-consistency","text":"The Kubernetes API guarantees consistency only on a single resource level. There are a couple of consequences for complex resource graphs as opposed to single resources: Error checking of properties spanning multiple resource will be asynchronous and eventually consistent. Simple syntax checks will be possible at the single resource level, but cross resource dependencies will need to be handled by the controller. Controllers will need to handle broken links between resources and/or mismatched configuration.","title":"Single resource consistency"},{"location":"concepts/#conflicts","text":"Separation and delegation of responsibility among independent actors (e.g between cluster ops and application developers) can result in conflicts in the configuration. For example, two application teams may inadvertently submit configuration for the same HTTP path. There are several different strategies for handling this: TODO","title":"Conflicts"},{"location":"concepts/#extensibility","text":"TODO","title":"Extensibility"},{"location":"concepts/#gatewayclass_1","text":"GatewayClass ( source code ) is cluster-scoped resource defined by the infrastructure provider. This resource represents a class of Gateways that can be instantiated. Note: this serves the same function as the networking.IngressClass resource . kind: GatewayClass metadata: name: cluster-gateway spec: controller: \"acme.io/gateway-controller\" We expect that one or more GatewayClasses will be created by the infrastructure provider for the user. It allows decoupling of which mechanism (e.g. controller) implements the Gateways from the user. For instance, an infrastructure provider may create two GatewayClasses named internet and private to reflect Gateways that define Internet-facing vs private, internal applications. kind: GatewayClass metadata: name: internet ... --- kind: GatewayClass metadata: name: private ... The user of the classes will not need to know how internet and private are implemented. Instead, the user will only need to understand the resulting properties of the class that the Gateway was created with.","title":"GatewayClass"},{"location":"concepts/#gatewayclass-parameters","text":"Providers of the Gateway API may need to pass parameters to their controller as part of the class definition. This is done using the GatewayClass.spec.parametersRef field: # GatewayClass for Gateways that define Internet-facing applications. kind: GatewayClass metadata: name: internet spec: controller: \"acme.io/gateway-controller\" parametersRef: apiVersion: core/v1 kind: ConfigMap namespace: acme-system name: internet-gateway --- kind: ConfigMap metadata: name: internet-gateway namespace: acme-system data: ip-address-pool: internet-vips ... The type of object referenced by GatewayClass.spec.parametersRef will depend on the provider itself. A core.ConfigMap is used in the example above, but controllers may opt to use a CustomResource for better schema validation.","title":"GatewayClass parameters"},{"location":"concepts/#gatewayclass-status","text":"GatewayClasses MUST be validated by the provider to ensure that the configured parameters are valid. The validity of the class will be signaled to the user via GatewayClass.status : kind: GatewayClass ... status: conditions: - type: InvalidParameters status: Unknown ... A new GatewayClass will start with the InvalidParameters condition set to Unknown . At this point the controller has not seen the configuration. Once the controller has processed the configuration, the condition will be set to False : kind: GatewayClass ... status: conditions: - type: InvalidParameters status: False ... If there is an error in the GatewayClass.spec , the conditions will be non-empty and contain information about the error. kind: GatewayClass ... status: conditions: - type: InvalidParameters status: True Reason: BadFooBar Message: \"foobar\" is an FooBar.","title":"GatewayClass status"},{"location":"concepts/#gateway_1","text":"A Gateway is 1:1 with the life cycle of the configuration of infrastructure. When a user creates a Gateway , some load balancing infrastructure is provisioned or configured (see below for details) by the GatewayClass controller. Gateway is the resource that triggers actions in this API. Other resources in this API are configuration snippets until a Gateway has been created to link the resources together. The Gateway spec defines the following: The GatewayClass used to instantiate this Gateway. The Listener bindings, which define addresses and ports, protocol termination, and TLS settings. The Listener configuration requested by a Gateway definition can be incompatible with a given GatewayClass (e.g. port/protocol combination is not supported). The Routes, which describe how traffic is processed and forwarded. If the Listener configuration requested by a Gateway definition is incompatible with a given GatewayClass, the Gateway will be in an error state, signaled by the status field.","title":"Gateway"},{"location":"concepts/#deployment-models","text":"Depending on the GatewayClass , the creation of the Gateway could do any of the following actions: Use cloud APIs to create an LB instance. Spawn a new instance of a software LB (in this or another cluster). Add a configuration stanza to an already instantiated LB to handle the new routes. Program the SDN to implement the configuration. Something else we haven\u2019t thought of yet... The API does not specify which one of these actions will be taken. Note that a GatewayClass controller that manages in-cluster proxy processes MAY restrict Gateway configuration scope, e.g. only be served in the same namespace.","title":"Deployment models"},{"location":"concepts/#gateway-status","text":"Gateways track status for the Gateway resource as a whole as well as each Listener it contains. The status for a specific Route is reported in the status of the Route resource. Within GatewayStatus , Listeners will have status entries corresponding to their name. Both GatewayStatus and ListenerStatus follow the conditions pattern used elsewhere in Kubernetes. This is a list that includes a type of condition, the status of that condition, and the last time this condition changed.","title":"Gateway Status"},{"location":"concepts/#listeners","text":"TODO","title":"Listeners"},{"location":"concepts/#routes","text":"TODO","title":"Routes"},{"location":"concepts/#httproute","text":"TODO","title":"HTTPRoute"},{"location":"concepts/#tcproute","text":"TODO","title":"TCPRoute"},{"location":"concepts/#generic-routing","text":"TODO","title":"Generic routing"},{"location":"concepts/#delegationinclusion","text":"TODO","title":"Delegation/inclusion"},{"location":"concepts/#destinations","text":"TODO","title":"Destinations"},{"location":"cookbook/","text":"API Cookbook TODO: Cookbook will be a page w/ examples for common tasks (exposing an HTTP service, configuring TLS, etc).","title":"API cookbook"},{"location":"cookbook/#api-cookbook","text":"TODO: Cookbook will be a page w/ examples for common tasks (exposing an HTTP service, configuring TLS, etc).","title":"API Cookbook"},{"location":"design-decisions/","text":"Design Decisions Throughout the design of these APIs some significant design decisions have been made. This provides some background on the factors considered when making these decisions. GatewayClass Scope Problem Moving to a namespace-scoped GatewayClass would provide more flexibility for RBAC configuration and simplify some use cases. This would also contradict the existing pattern for class resources to be cluster-scoped. Advantages of a Namespace-Scoped GatewayClass Namespaces could be used to separate different GatewayClasses, enabling admins to more closely restrict who can modify individual GatewayClasses. A full Gateway stack, including a GatewayClass, can be created by users with only namespace level access, similar to the initial implementation of Ingress. Enables a more restrictive (and potentially more secure) default for where a GatewayClass could be used. This could mean only allowing Gateways and Routes in the same namespace by default. Provides better model for using Service APIs on a management cluster designed to provision and manage other clusters and infrastructure needed by other clusters. Advantages of a Cluster-Scoped GatewayClass Consistent with existing class resources, including StorageClass and IngressClass, that are all cluster-scoped. Discussions with sig-storage showed that StorageClass had worked well as a cluster-scoped resource and that they were continuing to follow that pattern for new Class resources. Follows general pattern that resources managed by infrastructure provider and/or cluster administrators are cluster scoped. This matches the proposed security model for GatewayClass. Impossible for namespace level admins to grant RBAC permissions for GatewayClass resources. With a namespace-scoped resource, anyone that could configure RBAC within a namespace could grant GatewayClass access. Although both a namespace-scoped or cluster-scoped GatewayClass could be referenced from multiple namespaces, it's significantly more common for a cluster-scoped resource to be accessible from multiple namespaces. Works well when there are only a few total GatewayClasses per cluster, likely the majority of use cases. Simple globally unique names with no need to specify a namespace when referencing a GatewayClass. Decision The advantages of the cluster-scoped GatewayClass ended up outweighing the advantages of a namespace-scoped resource. This was primarily driven by the desire to maintain consistency with previous class resources. There was a high bar to move away from the established pattern here and we determined that these reasons did not quite reach that. For more context on this decision, refer to the corresponding pull request .","title":"Design Decisions"},{"location":"design-decisions/#design-decisions","text":"Throughout the design of these APIs some significant design decisions have been made. This provides some background on the factors considered when making these decisions.","title":"Design Decisions"},{"location":"design-decisions/#gatewayclass-scope","text":"","title":"GatewayClass Scope"},{"location":"design-decisions/#problem","text":"Moving to a namespace-scoped GatewayClass would provide more flexibility for RBAC configuration and simplify some use cases. This would also contradict the existing pattern for class resources to be cluster-scoped.","title":"Problem"},{"location":"design-decisions/#advantages-of-a-namespace-scoped-gatewayclass","text":"Namespaces could be used to separate different GatewayClasses, enabling admins to more closely restrict who can modify individual GatewayClasses. A full Gateway stack, including a GatewayClass, can be created by users with only namespace level access, similar to the initial implementation of Ingress. Enables a more restrictive (and potentially more secure) default for where a GatewayClass could be used. This could mean only allowing Gateways and Routes in the same namespace by default. Provides better model for using Service APIs on a management cluster designed to provision and manage other clusters and infrastructure needed by other clusters.","title":"Advantages of a Namespace-Scoped GatewayClass"},{"location":"design-decisions/#advantages-of-a-cluster-scoped-gatewayclass","text":"Consistent with existing class resources, including StorageClass and IngressClass, that are all cluster-scoped. Discussions with sig-storage showed that StorageClass had worked well as a cluster-scoped resource and that they were continuing to follow that pattern for new Class resources. Follows general pattern that resources managed by infrastructure provider and/or cluster administrators are cluster scoped. This matches the proposed security model for GatewayClass. Impossible for namespace level admins to grant RBAC permissions for GatewayClass resources. With a namespace-scoped resource, anyone that could configure RBAC within a namespace could grant GatewayClass access. Although both a namespace-scoped or cluster-scoped GatewayClass could be referenced from multiple namespaces, it's significantly more common for a cluster-scoped resource to be accessible from multiple namespaces. Works well when there are only a few total GatewayClasses per cluster, likely the majority of use cases. Simple globally unique names with no need to specify a namespace when referencing a GatewayClass.","title":"Advantages of a Cluster-Scoped GatewayClass"},{"location":"design-decisions/#decision","text":"The advantages of the cluster-scoped GatewayClass ended up outweighing the advantages of a namespace-scoped resource. This was primarily driven by the desire to maintain consistency with previous class resources. There was a high bar to move away from the established pattern here and we determined that these reasons did not quite reach that. For more context on this decision, refer to the corresponding pull request .","title":"Decision"},{"location":"devguide/","text":"Building, testing and deploying You will need to have Docker installed to perform the steps below. Project management We are using the Github issues and project dashboard to manage the list of TODOs for this project: Open issues Project dashboard Issues labeled good first issue and help wanted are especially good for a first contribution. Release cadence During the development phase, we expect to release on a monthly cadence. We are explicitly decoupling ourselves from the Kubernetes API versioning cycle to give us more flexibility to evolve the specification. As the specification solidifies, we will slow down our release cycle. General target timeline: 1H 2020: Monthly release cycle, with first release targeted for January 31 2H 2020: Slower release cycle Building the code The project uses make to drive the build. make will build the manager binary, run code generators, and run static analysis against the code. You can kick off an overall build from the top-level makefile: make Testing the code The easiest way to test the code is to use the kubebuilder created CRD with a kind cluster. Follow the installation instructions for kind in the README in the repo. kind create cluster ... # Install the CRDs make install # Remove the CRDs and associated CRs make uninstall Submitting a review TODO Verify Make sure you run the static analysis over the repo before submitting your changes. The Prow presubmit will not let your change merge if verification fails. make verify Documentation The site documentation is written in mkdocs format. The files are contained in docs-src/ . Generated files are in docs/ and published to Github Pages. Building the docs: make docs Live preview for editing (view on http://localhost:8000 , CTRL-C to quit): make serve Remove generated documentation files: make clean Publishing The docs are published automatically to Github pages . When making changes to the documentation, generate the new documentation and make the generated code a self-contained commit (e.g. the changes to docs/ ). This will keep the code reviews simple and clearly delineate user vs generated content.","title":"Developer guide"},{"location":"devguide/#building-testing-and-deploying","text":"You will need to have Docker installed to perform the steps below.","title":"Building, testing and deploying"},{"location":"devguide/#project-management","text":"We are using the Github issues and project dashboard to manage the list of TODOs for this project: Open issues Project dashboard Issues labeled good first issue and help wanted are especially good for a first contribution.","title":"Project management"},{"location":"devguide/#release-cadence","text":"During the development phase, we expect to release on a monthly cadence. We are explicitly decoupling ourselves from the Kubernetes API versioning cycle to give us more flexibility to evolve the specification. As the specification solidifies, we will slow down our release cycle. General target timeline: 1H 2020: Monthly release cycle, with first release targeted for January 31 2H 2020: Slower release cycle","title":"Release cadence"},{"location":"devguide/#building-the-code","text":"The project uses make to drive the build. make will build the manager binary, run code generators, and run static analysis against the code. You can kick off an overall build from the top-level makefile: make","title":"Building the code"},{"location":"devguide/#testing-the-code","text":"The easiest way to test the code is to use the kubebuilder created CRD with a kind cluster. Follow the installation instructions for kind in the README in the repo. kind create cluster ... # Install the CRDs make install # Remove the CRDs and associated CRs make uninstall","title":"Testing the code"},{"location":"devguide/#submitting-a-review","text":"TODO","title":"Submitting a review"},{"location":"devguide/#verify","text":"Make sure you run the static analysis over the repo before submitting your changes. The Prow presubmit will not let your change merge if verification fails. make verify","title":"Verify"},{"location":"devguide/#documentation","text":"The site documentation is written in mkdocs format. The files are contained in docs-src/ . Generated files are in docs/ and published to Github Pages. Building the docs: make docs Live preview for editing (view on http://localhost:8000 , CTRL-C to quit): make serve Remove generated documentation files: make clean","title":"Documentation"},{"location":"devguide/#publishing","text":"The docs are published automatically to Github pages . When making changes to the documentation, generate the new documentation and make the generated code a self-contained commit (e.g. the changes to docs/ ). This will keep the code reviews simple and clearly delineate user vs generated content.","title":"Publishing"},{"location":"enhancement-requests/","text":"Enhancement Tracking and Backlog Inspired by Kubernetes enhancements , service-api's provides a process for introducing new functionality or considerable changes to the project. The enhancement process will evolve over time as the project matures. Enhancements provides the basis of a community roadmap. Enhancements may be filed by anyone, but require approval from a maintainer to accept the enhancement into the project. Quick start Create an Issue and select \"Enhancement Request\". Follow the instructions in the enhancement request template and submit the Issue. What is Considered an Enhancement? An enhancement is generally anything that: impacts how a cluster is operated including addition or removal of significant capabilities introduces changes to an api needs significant effort to implement requires documentation to utilize It is unlikely to require an enhancement if it: fixes a bug adds more testing code refactors minimal impact to a release If you're unsure the proposed work requires an enhancement, file an issue and ask. When to Create a New Enhancement Create an enhancement once you have: circulated your idea to see if there is interest. identified community members who agree to work on and maintain the enhancement. enhancements may take several releases to complete. a prototype in your own fork (optional) Why are Enhancements Tracked As the project evolves, it's important that the service-api's community understands how the enhancement affects the project. Individually, it's hard to understand how all parts of the system interact, but as a community we can work together to build the right design and approach before getting too deep into an implementation. When to Comment on an Enhancement Issue Please comment on the enhancement issue to: - request a review or clarification on the process - update status of the enhancement effort - link to relevant issues in other repos","title":"Enhancement requests"},{"location":"enhancement-requests/#enhancement-tracking-and-backlog","text":"Inspired by Kubernetes enhancements , service-api's provides a process for introducing new functionality or considerable changes to the project. The enhancement process will evolve over time as the project matures. Enhancements provides the basis of a community roadmap. Enhancements may be filed by anyone, but require approval from a maintainer to accept the enhancement into the project.","title":"Enhancement Tracking and Backlog"},{"location":"enhancement-requests/#quick-start","text":"Create an Issue and select \"Enhancement Request\". Follow the instructions in the enhancement request template and submit the Issue.","title":"Quick start"},{"location":"enhancement-requests/#what-is-considered-an-enhancement","text":"An enhancement is generally anything that: impacts how a cluster is operated including addition or removal of significant capabilities introduces changes to an api needs significant effort to implement requires documentation to utilize It is unlikely to require an enhancement if it: fixes a bug adds more testing code refactors minimal impact to a release If you're unsure the proposed work requires an enhancement, file an issue and ask.","title":"What is Considered an Enhancement?"},{"location":"enhancement-requests/#when-to-create-a-new-enhancement","text":"Create an enhancement once you have: circulated your idea to see if there is interest. identified community members who agree to work on and maintain the enhancement. enhancements may take several releases to complete. a prototype in your own fork (optional)","title":"When to Create a New Enhancement"},{"location":"enhancement-requests/#why-are-enhancements-tracked","text":"As the project evolves, it's important that the service-api's community understands how the enhancement affects the project. Individually, it's hard to understand how all parts of the system interact, but as a community we can work together to build the right design and approach before getting too deep into an implementation.","title":"Why are Enhancements Tracked"},{"location":"enhancement-requests/#when-to-comment-on-an-enhancement-issue","text":"Please comment on the enhancement issue to: - request a review or clarification on the process - update status of the enhancement effort - link to relevant issues in other repos","title":"When to Comment on an Enhancement Issue"},{"location":"faq/","text":"Frequently Asked Questions (FAQ) Q: Will there be a default controller implementation (in this repo)? A: There is no current plan to have an \"official\" or \"default\" implementation. You will see the controller code in this repo be used for testing the support libraries.","title":"FAQ"},{"location":"faq/#frequently-asked-questions-faq","text":"Q: Will there be a default controller implementation (in this repo)? A: There is no current plan to have an \"official\" or \"default\" implementation. You will see the controller code in this repo be used for testing the support libraries.","title":"Frequently Asked Questions (FAQ)"},{"location":"feedback/","text":"Feedback and Bug Reports Feedback and bug reports should be filed as Github Issues on this repo. Be sure to use the following template: TODO","title":"Feedback"},{"location":"feedback/#feedback-and-bug-reports","text":"Feedback and bug reports should be filed as Github Issues on this repo. Be sure to use the following template: TODO","title":"Feedback and Bug Reports"},{"location":"releases/","text":"Releases Although Service APIs are an official Kubernetes project, and represent official APIs, these APIs will not be installed by default on Kubernetes clusters at this time. This project will use Custom Resource Definitions (CRDs) to represent the new API types that Service APIs include. Similar to other Kubernetes APIs, these will go through a formal Kubernetes Enhancement Proposal (KEP) review. Unlike other Kubernetes APIs, Service API releases will be independent from Kubernetes releases initially. Service API releases will include four components: * Custom Resource Definitions to define the API. * Go client libraries. * Validation webhooks to implement cross field validations. * Conversion webhooks to convert resources between API versions. Versioning Versioning will be completely separate from the Kubernetes release process, but similar methodology will be used. Service API versions will use the same version level requirements as other Kubernetes features . Service APIs are currently at the development stage of versioning described in the Kubernetes documentation above. An initial alpha release is currently planned for February 2020. A faster release cadence will be used for alpha versions, with new alpha releases monthly. Users and controller authors will be expected to use the latest version of the API. There will be little to no provisions for backwards compatibility for alpha versions. Generally we expect the alpha API to be for users and controller developers to test out the API but not in any production environment. Beta and stable releases will operate on a slower, more standard, release schedule. They will also provide all of the stability guarantees that other beta and stable Kubernetes features provide. Installation This project will be responsible for providing straightforward and reliable ways to install releases of Service APIs. Other Official Custom Resources This is a relatively new concept, and there is only one previous example of official custom resources being used: VolumeSnapshots . Although VolumeSnapshot CRDs can be installed directly by CSI drivers that support them, Service APIs must support multiple controllers per cluster, so the CRDs will live in and be installed from this repo.","title":"Releases"},{"location":"releases/#releases","text":"Although Service APIs are an official Kubernetes project, and represent official APIs, these APIs will not be installed by default on Kubernetes clusters at this time. This project will use Custom Resource Definitions (CRDs) to represent the new API types that Service APIs include. Similar to other Kubernetes APIs, these will go through a formal Kubernetes Enhancement Proposal (KEP) review. Unlike other Kubernetes APIs, Service API releases will be independent from Kubernetes releases initially. Service API releases will include four components: * Custom Resource Definitions to define the API. * Go client libraries. * Validation webhooks to implement cross field validations. * Conversion webhooks to convert resources between API versions.","title":"Releases"},{"location":"releases/#versioning","text":"Versioning will be completely separate from the Kubernetes release process, but similar methodology will be used. Service API versions will use the same version level requirements as other Kubernetes features . Service APIs are currently at the development stage of versioning described in the Kubernetes documentation above. An initial alpha release is currently planned for February 2020. A faster release cadence will be used for alpha versions, with new alpha releases monthly. Users and controller authors will be expected to use the latest version of the API. There will be little to no provisions for backwards compatibility for alpha versions. Generally we expect the alpha API to be for users and controller developers to test out the API but not in any production environment. Beta and stable releases will operate on a slower, more standard, release schedule. They will also provide all of the stability guarantees that other beta and stable Kubernetes features provide.","title":"Versioning"},{"location":"releases/#installation","text":"This project will be responsible for providing straightforward and reliable ways to install releases of Service APIs.","title":"Installation"},{"location":"releases/#other-official-custom-resources","text":"This is a relatively new concept, and there is only one previous example of official custom resources being used: VolumeSnapshots . Although VolumeSnapshot CRDs can be installed directly by CSI drivers that support them, Service APIs must support multiple controllers per cluster, so the CRDs will live in and be installed from this repo.","title":"Other Official Custom Resources"},{"location":"security-model/","text":"Security Model Introduction The Service APIs have been designed to enable granular authorization for each role in a typical organization. Resources The Service APIs have 4 primary API resources: GatewayClass defines a set of gateways with a common configuration and behavior. Gateway requests a point where traffic can be translated to Services within the cluster. Routes describe how traffic coming via the Gateway maps to the Services. TrafficSplits describe how traffic may be split from Routes. Additional Configuration There are two additional pieces of configuration that are important in this security model: Which namespaces can contain Gateways of the specified GatewayClass. Which namespaces Routes can be targeted in by Gateways of the specified GatewayClass. Roles For the purposes of this security model, 3 common roles have been identified: Infrastructure provider : The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include: the cloud provider (AWS, Azure, GCP, ...), the PaaS provider in a company. Cluster operator : The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, application permissions. Application developer : The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends). Although these roles can cover a wide variety of use cases, some organizations may be structured slightly differently. Many organizations may also have a fourth role that sits between \"cluster operator\" and \"application developer\": Application admin : The application admin has administrative access to some namespaces within a cluster, but not the cluster as a whole. The Security Model There are two primary components to the Service APIs security model: RBAC and namespace restrictions. RBAC RBAC (role-based access control) is the standard used for Kubernetes authorization. This allows users to configure who can perform actions on resources in specific scopes. RBAC can be used to enable each of the roles defined above. In most cases, it will be desirable to have all resources be readable by most roles, so instead we'll focus on write access for this model. Write Permissions for Simple 3 Tier Model GatewayClass Gateway Route TrafficSplit Infrastructure Provider Yes Yes Yes Yes Cluster Operators No Yes Yes Yes Application Developers No No Yes Yes Write Permissions for Advanced 4 Tier Model GatewayClass Gateway Route TrafficSplit Infrastructure Provider Yes Yes Yes Yes Cluster Operators Sometimes Yes Yes Yes Application Admins No In Specified Namespaces In Specified Namespaces In Specified Namespaces Application Developers No No In Specified Namespaces In Specified Namespaces Namespace Restrictions The extra configuration options are not possible to control with RBAC. Instead, they will be controlled with configuration fields on GatewayClasses: allowedGatewayNamespaces : This field is a selector of namespaces that Gateways can use this GatewayClass from. This is a standard Kubernetes LabelSelector, a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. Controllers must not support Gateways in namespaces outside this selector. An empty selector (default) indicates that Gateways can use this GatewayClass from any namespace. This field is intentionally not a pointer because the nil behavior (no namespaces) is undesirable here. allowedRouteNamespaces : This field is a selector of namespaces that Gateways of this class can reference Routes in. This is a standard Kubernetes LabelSelector, a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. Controllers must not support Routes in namespaces outside this selector. A nil selector (default) indicates that Gateways of this class can reference Routes within the same namespace. An empty selector indicates that Gateways can reference Routes in any namespace. This field is intentionally a pointer to support the nil behavior (only local Routes allowed). Controller Requirements To be considered conformant with the Service APIs spec, controllers need to: Populate status fields on Gateways and Resources to indicate if they are compatible with the corresponding GatewayClass configuration. Not implement invalid configuration. Fore example, if a route is referenced in an invalid namespace for the GatewayClass, it should be ignored. Respond to changes in GatewayClass configuration that may change which Gateways or Routes are valid. Alternative Approaches Considered New API Resources We considered introducing new API resources to cover these use cases. These resources might be look something like: ClusterGateway : A ClusterGateway could reference routes in any namespace. ClusterRoute : A ClusterRoute could be referenced by any Gateway or ClusterGateway. Benefits Easy to model with RBAC. API validation tied directly to each resource. Downsides New resources to deal with - more informers, clients, documentation, etc. Harder to expand with additional options in the future - may just end up with tons of API resources to cover all use cases. Boolean Multi Namespace Route Indicator on GatewayClass Instead of having the routeNamespaceSelector field on GatewayClass, we would use a boolean multiNamespaceRoutes field to indicate if Gateways of this class can target routes in multiple namespaces. This would default to false. A false value here would indicate that routes could only be targeted in the current namespace. Benefits Helpful for multi-tenant use cases with many isolated Gateways. Simple configuration with an easy to understand default value. Downsides GatewayClass admins are unable to partially limit namespaces that can be targeted by Gateways. Admins would have to choose between allowing access to Routes in all namespaces or only the local one. Validating Webhook A validating webhook could potentially handle some of the cross-resource validation necessary for this security model and provide more immediate feedback to end users. Benefits Immediate validation feedback. More validation logic stays in core Service APIs codebase. Downsides Imperfect solution for cross-resource validation. For example, a change to a GatewayClass could affect the validity of corresponding Gateway. Additional complexity involved in installing Service APIs in a cluster.","title":"Security Model"},{"location":"security-model/#security-model","text":"","title":"Security Model"},{"location":"security-model/#introduction","text":"The Service APIs have been designed to enable granular authorization for each role in a typical organization.","title":"Introduction"},{"location":"security-model/#resources","text":"The Service APIs have 4 primary API resources: GatewayClass defines a set of gateways with a common configuration and behavior. Gateway requests a point where traffic can be translated to Services within the cluster. Routes describe how traffic coming via the Gateway maps to the Services. TrafficSplits describe how traffic may be split from Routes.","title":"Resources"},{"location":"security-model/#additional-configuration","text":"There are two additional pieces of configuration that are important in this security model: Which namespaces can contain Gateways of the specified GatewayClass. Which namespaces Routes can be targeted in by Gateways of the specified GatewayClass.","title":"Additional Configuration"},{"location":"security-model/#roles","text":"For the purposes of this security model, 3 common roles have been identified: Infrastructure provider : The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include: the cloud provider (AWS, Azure, GCP, ...), the PaaS provider in a company. Cluster operator : The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, application permissions. Application developer : The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends). Although these roles can cover a wide variety of use cases, some organizations may be structured slightly differently. Many organizations may also have a fourth role that sits between \"cluster operator\" and \"application developer\": Application admin : The application admin has administrative access to some namespaces within a cluster, but not the cluster as a whole.","title":"Roles"},{"location":"security-model/#the-security-model","text":"There are two primary components to the Service APIs security model: RBAC and namespace restrictions.","title":"The Security Model"},{"location":"security-model/#rbac","text":"RBAC (role-based access control) is the standard used for Kubernetes authorization. This allows users to configure who can perform actions on resources in specific scopes. RBAC can be used to enable each of the roles defined above. In most cases, it will be desirable to have all resources be readable by most roles, so instead we'll focus on write access for this model.","title":"RBAC"},{"location":"security-model/#write-permissions-for-simple-3-tier-model","text":"GatewayClass Gateway Route TrafficSplit Infrastructure Provider Yes Yes Yes Yes Cluster Operators No Yes Yes Yes Application Developers No No Yes Yes","title":"Write Permissions for Simple 3 Tier Model"},{"location":"security-model/#write-permissions-for-advanced-4-tier-model","text":"GatewayClass Gateway Route TrafficSplit Infrastructure Provider Yes Yes Yes Yes Cluster Operators Sometimes Yes Yes Yes Application Admins No In Specified Namespaces In Specified Namespaces In Specified Namespaces Application Developers No No In Specified Namespaces In Specified Namespaces","title":"Write Permissions for Advanced 4 Tier Model"},{"location":"security-model/#namespace-restrictions","text":"The extra configuration options are not possible to control with RBAC. Instead, they will be controlled with configuration fields on GatewayClasses: allowedGatewayNamespaces : This field is a selector of namespaces that Gateways can use this GatewayClass from. This is a standard Kubernetes LabelSelector, a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. Controllers must not support Gateways in namespaces outside this selector. An empty selector (default) indicates that Gateways can use this GatewayClass from any namespace. This field is intentionally not a pointer because the nil behavior (no namespaces) is undesirable here. allowedRouteNamespaces : This field is a selector of namespaces that Gateways of this class can reference Routes in. This is a standard Kubernetes LabelSelector, a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. Controllers must not support Routes in namespaces outside this selector. A nil selector (default) indicates that Gateways of this class can reference Routes within the same namespace. An empty selector indicates that Gateways can reference Routes in any namespace. This field is intentionally a pointer to support the nil behavior (only local Routes allowed).","title":"Namespace Restrictions"},{"location":"security-model/#controller-requirements","text":"To be considered conformant with the Service APIs spec, controllers need to: Populate status fields on Gateways and Resources to indicate if they are compatible with the corresponding GatewayClass configuration. Not implement invalid configuration. Fore example, if a route is referenced in an invalid namespace for the GatewayClass, it should be ignored. Respond to changes in GatewayClass configuration that may change which Gateways or Routes are valid.","title":"Controller Requirements"},{"location":"security-model/#alternative-approaches-considered","text":"","title":"Alternative Approaches Considered"},{"location":"security-model/#new-api-resources","text":"We considered introducing new API resources to cover these use cases. These resources might be look something like: ClusterGateway : A ClusterGateway could reference routes in any namespace. ClusterRoute : A ClusterRoute could be referenced by any Gateway or ClusterGateway. Benefits Easy to model with RBAC. API validation tied directly to each resource. Downsides New resources to deal with - more informers, clients, documentation, etc. Harder to expand with additional options in the future - may just end up with tons of API resources to cover all use cases.","title":"New API Resources"},{"location":"security-model/#boolean-multi-namespace-route-indicator-on-gatewayclass","text":"Instead of having the routeNamespaceSelector field on GatewayClass, we would use a boolean multiNamespaceRoutes field to indicate if Gateways of this class can target routes in multiple namespaces. This would default to false. A false value here would indicate that routes could only be targeted in the current namespace. Benefits Helpful for multi-tenant use cases with many isolated Gateways. Simple configuration with an easy to understand default value. Downsides GatewayClass admins are unable to partially limit namespaces that can be targeted by Gateways. Admins would have to choose between allowing access to Routes in all namespaces or only the local one.","title":"Boolean Multi Namespace Route Indicator on GatewayClass"},{"location":"security-model/#validating-webhook","text":"A validating webhook could potentially handle some of the cross-resource validation necessary for this security model and provide more immediate feedback to end users. Benefits Immediate validation feedback. More validation logic stays in core Service APIs codebase. Downsides Imperfect solution for cross-resource validation. For example, a change to a GatewayClass could affect the validity of corresponding Gateway. Additional complexity involved in installing Service APIs in a cluster.","title":"Validating Webhook"},{"location":"spec/","text":"API specification TODO","title":"API specification"},{"location":"spec/#api-specification","text":"TODO","title":"API specification"},{"location":"userguide/","text":"API user guide TODO","title":"User guide"},{"location":"userguide/#api-user-guide","text":"TODO","title":"API user guide"}]}