/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	apisv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// ListenerApplyConfiguration represents a declarative configuration of the Listener type for use
// with apply.
//
// Listener embodies the concept of a logical endpoint where a Gateway accepts
// network connections.
type ListenerApplyConfiguration struct {
	// Name is the name of the Listener. This name MUST be unique within a
	// Gateway.
	//
	// Support: Core
	Name *apisv1.SectionName `json:"name,omitempty"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match both the SNI and Host header.
	// Note that this does not require the SNI and Host header to be the same.
	// The semantics of this are described in more detail below.
	//
	// To ensure security, Section 11.1 of RFC-6066 emphasizes that server
	// implementations that rely on SNI hostname matching MUST also verify
	// hostnames within the application protocol.
	//
	// Section 9.1.2 of RFC-7540 provides a mechanism for servers to reject the
	// reuse of a connection by responding with the HTTP 421 Misdirected Request
	// status code. This indicates that the origin server has rejected the
	// request because it appears to have been misdirected.
	//
	// To detect misdirected requests, Gateways SHOULD match the authority of
	// the requests with all the SNI hostname(s) configured across all the
	// Gateway Listeners on the same port and protocol:
	//
	// * If another Listener has an exact match or more specific wildcard entry,
	// the Gateway SHOULD return a 421.
	// * If the current Listener (selected by SNI matching during ClientHello)
	// does not match the Host:
	// * If another Listener does match the Host, the Gateway SHOULD return a
	// 421.
	// * If no other Listener matches the Host, the Gateway MUST return a
	// 404.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	//
	// Support: Core
	Hostname *apisv1.Hostname `json:"hostname,omitempty"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	//
	// Support: Core
	Port *int32 `json:"port,omitempty"`
	// Protocol specifies the network protocol this listener expects to receive.
	//
	// Support: Core
	Protocol *apisv1.ProtocolType `json:"protocol,omitempty"`
	// TLS is the TLS configuration for the Listener. This field is required if
	// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
	// if the Protocol field is "HTTP", "TCP", or "UDP".
	//
	// The association of SNIs to Certificate defined in ListenerTLSConfig is
	// defined based on the Hostname field for this listener.
	//
	// The GatewayClass MUST use the longest matching SNI out of all
	// available certificates for any TLS handshake.
	//
	// Support: Core
	TLS *ListenerTLSConfigApplyConfiguration `json:"tls,omitempty"`
	// AllowedRoutes defines the types of routes that MAY be attached to a
	// Listener and the trusted namespaces where those Route resources MAY be
	// present.
	//
	// Although a client request may match multiple route rules, only one rule
	// may ultimately receive the request. Matching precedence MUST be
	// determined in order of the following criteria:
	//
	// * The most specific match as defined by the Route type.
	// * The oldest Route based on creation timestamp. For example, a Route with
	// a creation timestamp of "2020-09-08 01:02:03" is given precedence over
	// a Route with a creation timestamp of "2020-09-08 01:02:04".
	// * If everything else is equivalent, the Route appearing first in
	// alphabetical order (namespace/name) should be given precedence. For
	// example, foo/bar is given precedence over foo/baz.
	//
	// All valid rules within a Route attached to this Listener should be
	// implemented. Invalid Route rules can be ignored (sometimes that will mean
	// the full Route). If a Route rule transitions from valid to invalid,
	// support for that Route rule should be dropped to ensure consistency. For
	// example, even if a filter specified by a Route rule is invalid, the rest
	// of the rules within that Route should still be supported.
	//
	// Support: Core
	AllowedRoutes *AllowedRoutesApplyConfiguration `json:"allowedRoutes,omitempty"`
}

// ListenerApplyConfiguration constructs a declarative configuration of the Listener type for use with
// apply.
func Listener() *ListenerApplyConfiguration {
	return &ListenerApplyConfiguration{}
}

// WithName sets the Name field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Name field is set to the value of the last call.
func (b *ListenerApplyConfiguration) WithName(value apisv1.SectionName) *ListenerApplyConfiguration {
	b.Name = &value
	return b
}

// WithHostname sets the Hostname field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Hostname field is set to the value of the last call.
func (b *ListenerApplyConfiguration) WithHostname(value apisv1.Hostname) *ListenerApplyConfiguration {
	b.Hostname = &value
	return b
}

// WithPort sets the Port field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Port field is set to the value of the last call.
func (b *ListenerApplyConfiguration) WithPort(value int32) *ListenerApplyConfiguration {
	b.Port = &value
	return b
}

// WithProtocol sets the Protocol field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Protocol field is set to the value of the last call.
func (b *ListenerApplyConfiguration) WithProtocol(value apisv1.ProtocolType) *ListenerApplyConfiguration {
	b.Protocol = &value
	return b
}

// WithTLS sets the TLS field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TLS field is set to the value of the last call.
func (b *ListenerApplyConfiguration) WithTLS(value *ListenerTLSConfigApplyConfiguration) *ListenerApplyConfiguration {
	b.TLS = value
	return b
}

// WithAllowedRoutes sets the AllowedRoutes field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AllowedRoutes field is set to the value of the last call.
func (b *ListenerApplyConfiguration) WithAllowedRoutes(value *AllowedRoutesApplyConfiguration) *ListenerApplyConfiguration {
	b.AllowedRoutes = value
	return b
}
