/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	apisv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// GatewayInfrastructureApplyConfiguration represents a declarative configuration of the GatewayInfrastructure type for use
// with apply.
//
// GatewayInfrastructure defines infrastructure level attributes about a Gateway instance.
type GatewayInfrastructureApplyConfiguration struct {
	// Labels that SHOULD be applied to any resources created in response to this Gateway.
	//
	// For implementations creating other Kubernetes objects, this should be the `metadata.labels` field on resources.
	// For other implementations, this refers to any relevant (implementation specific) "labels" concepts.
	//
	// An implementation may chose to add additional implementation-specific labels as they see fit.
	//
	// If an implementation maps these labels to Pods, or any other resource that would need to be recreated when labels
	// change, it SHOULD clearly warn about this behavior in documentation.
	//
	// Support: Extended
	Labels map[apisv1.LabelKey]apisv1.LabelValue `json:"labels,omitempty"`
	// Annotations that SHOULD be applied to any resources created in response to this Gateway.
	//
	// For implementations creating other Kubernetes objects, this should be the `metadata.annotations` field on resources.
	// For other implementations, this refers to any relevant (implementation specific) "annotations" concepts.
	//
	// An implementation may chose to add additional implementation-specific annotations as they see fit.
	//
	// Support: Extended
	Annotations map[apisv1.AnnotationKey]apisv1.AnnotationValue `json:"annotations,omitempty"`
	// ParametersRef is a reference to a resource that contains the configuration
	// parameters corresponding to the Gateway. This is optional if the
	// controller does not require any additional configuration.
	//
	// # This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway basis
	//
	// The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,
	// the merging behavior is implementation specific.
	// It is generally recommended that GatewayClass provides defaults that can be overridden by a Gateway.
	//
	// If the referent cannot be found, refers to an unsupported kind, or when
	// the data within that resource is malformed, the Gateway SHOULD be
	// rejected with the "Accepted" status condition set to "False" and an
	// "InvalidParameters" reason.
	//
	// Support: Implementation-specific
	ParametersRef *LocalParametersReferenceApplyConfiguration `json:"parametersRef,omitempty"`
}

// GatewayInfrastructureApplyConfiguration constructs a declarative configuration of the GatewayInfrastructure type for use with
// apply.
func GatewayInfrastructure() *GatewayInfrastructureApplyConfiguration {
	return &GatewayInfrastructureApplyConfiguration{}
}

// WithLabels puts the entries into the Labels field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Labels field,
// overwriting an existing map entries in Labels field with the same key.
func (b *GatewayInfrastructureApplyConfiguration) WithLabels(entries map[apisv1.LabelKey]apisv1.LabelValue) *GatewayInfrastructureApplyConfiguration {
	if b.Labels == nil && len(entries) > 0 {
		b.Labels = make(map[apisv1.LabelKey]apisv1.LabelValue, len(entries))
	}
	for k, v := range entries {
		b.Labels[k] = v
	}
	return b
}

// WithAnnotations puts the entries into the Annotations field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Annotations field,
// overwriting an existing map entries in Annotations field with the same key.
func (b *GatewayInfrastructureApplyConfiguration) WithAnnotations(entries map[apisv1.AnnotationKey]apisv1.AnnotationValue) *GatewayInfrastructureApplyConfiguration {
	if b.Annotations == nil && len(entries) > 0 {
		b.Annotations = make(map[apisv1.AnnotationKey]apisv1.AnnotationValue, len(entries))
	}
	for k, v := range entries {
		b.Annotations[k] = v
	}
	return b
}

// WithParametersRef sets the ParametersRef field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ParametersRef field is set to the value of the last call.
func (b *GatewayInfrastructureApplyConfiguration) WithParametersRef(value *LocalParametersReferenceApplyConfiguration) *GatewayInfrastructureApplyConfiguration {
	b.ParametersRef = value
	return b
}
