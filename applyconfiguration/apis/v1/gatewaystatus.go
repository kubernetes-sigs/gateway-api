/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	metav1 "k8s.io/client-go/applyconfigurations/meta/v1"
)

// GatewayStatusApplyConfiguration represents a declarative configuration of the GatewayStatus type for use
// with apply.
//
// GatewayStatus defines the observed state of Gateway.
type GatewayStatusApplyConfiguration struct {
	// Addresses lists the network addresses that have been bound to the
	// Gateway.
	//
	// This list may differ from the addresses provided in the spec under some
	// conditions:
	//
	// * no addresses are specified, all addresses are dynamically assigned
	// * a combination of specified and dynamic addresses are assigned
	// * a specified address was unusable (e.g. already in use)
	//
	// <gateway:validateIPAddress>
	Addresses []GatewayStatusAddressApplyConfiguration `json:"addresses,omitempty"`
	// Conditions describe the current conditions of the Gateway.
	//
	// Implementations should prefer to express Gateway conditions
	// using the `GatewayConditionType` and `GatewayConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe Gateway state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	// * "Ready"
	//
	// <gateway:util:excludeFromCRD>
	// Notes for implementors:
	//
	// Conditions are a listType `map`, which means that they function like a
	// map with a key of the `type` field _in the k8s apiserver_.
	//
	// This means that implementations must obey some rules when updating this
	// section.
	//
	// * Implementations MUST perform a read-modify-write cycle on this field
	// before modifying it. That is, when modifying this field, implementations
	// must be confident they have fetched the most recent version of this field,
	// and ensure that changes they make are on that recent version.
	// * Implementations MUST NOT remove or reorder Conditions that they are not
	// directly responsible for. For example, if an implementation sees a Condition
	// with type `special.io/SomeField`, it MUST NOT remove, change or update that
	// Condition.
	// * Implementations MUST always _merge_ changes into Conditions of the same Type,
	// rather than creating more than one Condition of the same Type.
	// * Implementations MUST always update the `observedGeneration` field of the
	// Condition to the `metadata.generation` of the Gateway at the time of update creation.
	// * If the `observedGeneration` of a Condition is _greater than_ the value the
	// implementation knows about, then it MUST NOT perform the update on that Condition,
	// but must wait for a future reconciliation and status update. (The assumption is that
	// the implementation's copy of the object is stale and an update will be re-triggered
	// if relevant.)
	// </gateway:util:excludeFromCRD>
	Conditions []metav1.ConditionApplyConfiguration `json:"conditions,omitempty"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners []ListenerStatusApplyConfiguration `json:"listeners,omitempty"`
	// AttachedListenerSets represents the total number of ListenerSets that have been
	// successfully attached to this Gateway.
	//
	// A ListenerSet is successfully attached to a Gateway when all the following conditions are met:
	// - The ListenerSet is selected by the Gateway's AllowedListeners field
	// - The ListenerSet has a valid ParentRef selecting the Gateway
	// - The ListenerSet's status has the condition "Accepted: true"
	//
	// Uses for this field include troubleshooting AttachedListenerSets attachment and
	// measuring blast radius/impact of changes to a Gateway.
	AttachedListenerSets *int32 `json:"attachedListenerSets,omitempty"`
}

// GatewayStatusApplyConfiguration constructs a declarative configuration of the GatewayStatus type for use with
// apply.
func GatewayStatus() *GatewayStatusApplyConfiguration {
	return &GatewayStatusApplyConfiguration{}
}

// WithAddresses adds the given value to the Addresses field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Addresses field.
func (b *GatewayStatusApplyConfiguration) WithAddresses(values ...*GatewayStatusAddressApplyConfiguration) *GatewayStatusApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithAddresses")
		}
		b.Addresses = append(b.Addresses, *values[i])
	}
	return b
}

// WithConditions adds the given value to the Conditions field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Conditions field.
func (b *GatewayStatusApplyConfiguration) WithConditions(values ...*metav1.ConditionApplyConfiguration) *GatewayStatusApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithConditions")
		}
		b.Conditions = append(b.Conditions, *values[i])
	}
	return b
}

// WithListeners adds the given value to the Listeners field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Listeners field.
func (b *GatewayStatusApplyConfiguration) WithListeners(values ...*ListenerStatusApplyConfiguration) *GatewayStatusApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithListeners")
		}
		b.Listeners = append(b.Listeners, *values[i])
	}
	return b
}

// WithAttachedListenerSets sets the AttachedListenerSets field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AttachedListenerSets field is set to the value of the last call.
func (b *GatewayStatusApplyConfiguration) WithAttachedListenerSets(value int32) *GatewayStatusApplyConfiguration {
	b.AttachedListenerSets = &value
	return b
}
