/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	metav1 "k8s.io/client-go/applyconfigurations/meta/v1"
	apisv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// ListenerStatusApplyConfiguration represents a declarative configuration of the ListenerStatus type for use
// with apply.
//
// ListenerStatus is the status associated with a Listener.
type ListenerStatusApplyConfiguration struct {
	// Name is the name of the Listener that this status corresponds to.
	Name *apisv1.SectionName `json:"name,omitempty"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds supported by an implementation for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds []RouteGroupKindApplyConfiguration `json:"supportedKinds,omitempty"`
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners, even if the Accepted condition of an individual Listener is set
	// to "False". The AttachedRoutes number represents the number of Routes with
	// the Accepted condition set to "True" that have been attached to this Listener.
	// Routes with any other value for the Accepted condition MUST NOT be included
	// in this count.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes *int32 `json:"attachedRoutes,omitempty"`
	// Conditions describe the current condition of this listener.
	//
	// <gateway:util:excludeFromCRD>
	// Notes for implementors:
	//
	// Conditions are a listType `map`, which means that they function like a
	// map with a key of the `type` field _in the k8s apiserver_.
	//
	// This means that implementations must obey some rules when updating this
	// section.
	//
	// * Implementations MUST perform a read-modify-write cycle on this field
	// before modifying it. That is, when modifying this field, implementations
	// must be confident they have fetched the most recent version of this field,
	// and ensure that changes they make are on that recent version.
	// * Implementations MUST NOT remove or reorder Conditions that they are not
	// directly responsible for. For example, if an implementation sees a Condition
	// with type `special.io/SomeField`, it MUST NOT remove, change or update that
	// Condition.
	// * Implementations MUST always _merge_ changes into Conditions of the same Type,
	// rather than creating more than one Condition of the same Type.
	// * Implementations MUST always update the `observedGeneration` field of the
	// Condition to the `metadata.generation` of the Gateway at the time of update creation.
	// * If the `observedGeneration` of a Condition is _greater than_ the value the
	// implementation knows about, then it MUST NOT perform the update on that Condition,
	// but must wait for a future reconciliation and status update. (The assumption is that
	// the implementation's copy of the object is stale and an update will be re-triggered
	// if relevant.)
	//
	// </gateway:util:excludeFromCRD>
	Conditions []metav1.ConditionApplyConfiguration `json:"conditions,omitempty"`
}

// ListenerStatusApplyConfiguration constructs a declarative configuration of the ListenerStatus type for use with
// apply.
func ListenerStatus() *ListenerStatusApplyConfiguration {
	return &ListenerStatusApplyConfiguration{}
}

// WithName sets the Name field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Name field is set to the value of the last call.
func (b *ListenerStatusApplyConfiguration) WithName(value apisv1.SectionName) *ListenerStatusApplyConfiguration {
	b.Name = &value
	return b
}

// WithSupportedKinds adds the given value to the SupportedKinds field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the SupportedKinds field.
func (b *ListenerStatusApplyConfiguration) WithSupportedKinds(values ...*RouteGroupKindApplyConfiguration) *ListenerStatusApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithSupportedKinds")
		}
		b.SupportedKinds = append(b.SupportedKinds, *values[i])
	}
	return b
}

// WithAttachedRoutes sets the AttachedRoutes field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AttachedRoutes field is set to the value of the last call.
func (b *ListenerStatusApplyConfiguration) WithAttachedRoutes(value int32) *ListenerStatusApplyConfiguration {
	b.AttachedRoutes = &value
	return b
}

// WithConditions adds the given value to the Conditions field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Conditions field.
func (b *ListenerStatusApplyConfiguration) WithConditions(values ...*metav1.ConditionApplyConfiguration) *ListenerStatusApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithConditions")
		}
		b.Conditions = append(b.Conditions, *values[i])
	}
	return b
}
