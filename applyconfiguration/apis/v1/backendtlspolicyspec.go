/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	apisv1 "sigs.k8s.io/gateway-api/apis/v1"
)

// BackendTLSPolicySpecApplyConfiguration represents a declarative configuration of the BackendTLSPolicySpec type for use
// with apply.
//
// BackendTLSPolicySpec defines the desired state of BackendTLSPolicy.
//
// Support: Extended
type BackendTLSPolicySpecApplyConfiguration struct {
	// TargetRefs identifies an API object to apply the policy to.
	// Note that this config applies to the entire referenced resource
	// by default, but this default may change in the future to provide
	// a more granular application of the policy.
	//
	// TargetRefs must be _distinct_. This means either that:
	//
	// * They select different targets. If this is the case, then targetRef
	// entries are distinct. In terms of fields, this means that the
	// multi-part key defined by `group`, `kind`, and `name` must
	// be unique across all targetRef entries in the BackendTLSPolicy.
	// * They select different sectionNames in the same target.
	//
	// When more than one BackendTLSPolicy selects the same target and
	// sectionName, implementations MUST determine precedence using the
	// following criteria, continuing on ties:
	//
	// * The older policy by creation timestamp takes precedence. For
	// example, a policy with a creation timestamp of "2021-07-15
	// 01:02:03" MUST be given precedence over a policy with a
	// creation timestamp of "2021-07-15 01:02:04".
	// * The policy appearing first in alphabetical order by {name}.
	// For example, a policy named `bar` is given precedence over a
	// policy named `baz`.
	//
	// For any BackendTLSPolicy that does not take precedence, the
	// implementation MUST ensure the `Accepted` Condition is set to
	// `status: False`, with Reason `Conflicted`.
	//
	// Implementations SHOULD NOT support more than one targetRef at this
	// time. Although the API technically allows for this, the current guidance
	// for conflict resolution and status handling is lacking. Until that can be
	// clarified in a future release, the safest approach is to support a single
	// targetRef.
	//
	// Support Levels:
	//
	// * Extended: Kubernetes Service referenced by HTTPRoute backendRefs.
	//
	// * Implementation-Specific: Services not connected via HTTPRoute, and any
	// other kind of backend. Implementations MAY use BackendTLSPolicy for:
	// - Services not referenced by any Route (e.g., infrastructure services)
	// - Gateway feature backends (e.g., ExternalAuth, rate-limiting services)
	// - Service mesh workload-to-service communication
	// - Other resource types beyond Service
	//
	// Implementations SHOULD aim to ensure that BackendTLSPolicy behavior is consistent,
	// even outside of the extended HTTPRoute -(backendRef) -> Service path.
	// They SHOULD clearly document how BackendTLSPolicy is interpreted in these
	// scenarios, including:
	// - Which resources beyond Service are supported
	// - How the policy is discovered and applied
	// - Any implementation-specific semantics or restrictions
	//
	// Note that this config applies to the entire referenced resource
	// by default, but this default may change in the future to provide
	// a more granular application of the policy.
	TargetRefs []LocalPolicyTargetReferenceWithSectionNameApplyConfiguration `json:"targetRefs,omitempty"`
	// Validation contains backend TLS validation configuration.
	Validation *BackendTLSPolicyValidationApplyConfiguration `json:"validation,omitempty"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options map[apisv1.AnnotationKey]apisv1.AnnotationValue `json:"options,omitempty"`
}

// BackendTLSPolicySpecApplyConfiguration constructs a declarative configuration of the BackendTLSPolicySpec type for use with
// apply.
func BackendTLSPolicySpec() *BackendTLSPolicySpecApplyConfiguration {
	return &BackendTLSPolicySpecApplyConfiguration{}
}

// WithTargetRefs adds the given value to the TargetRefs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the TargetRefs field.
func (b *BackendTLSPolicySpecApplyConfiguration) WithTargetRefs(values ...*LocalPolicyTargetReferenceWithSectionNameApplyConfiguration) *BackendTLSPolicySpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithTargetRefs")
		}
		b.TargetRefs = append(b.TargetRefs, *values[i])
	}
	return b
}

// WithValidation sets the Validation field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Validation field is set to the value of the last call.
func (b *BackendTLSPolicySpecApplyConfiguration) WithValidation(value *BackendTLSPolicyValidationApplyConfiguration) *BackendTLSPolicySpecApplyConfiguration {
	b.Validation = value
	return b
}

// WithOptions puts the entries into the Options field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Options field,
// overwriting an existing map entries in Options field with the same key.
func (b *BackendTLSPolicySpecApplyConfiguration) WithOptions(entries map[apisv1.AnnotationKey]apisv1.AnnotationValue) *BackendTLSPolicySpecApplyConfiguration {
	if b.Options == nil && len(entries) > 0 {
		b.Options = make(map[apisv1.AnnotationKey]apisv1.AnnotationValue, len(entries))
	}
	for k, v := range entries {
		b.Options[k] = v
	}
	return b
}
