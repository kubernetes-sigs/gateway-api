/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1alpha1

import (
	v1 "sigs.k8s.io/gateway-api/applyconfiguration/apis/v1"
)

// BackendTrafficPolicySpecApplyConfiguration represents a declarative configuration of the BackendTrafficPolicySpec type for use
// with apply.
//
// BackendTrafficPolicySpec define the desired state of BackendTrafficPolicy
// Note: there is no Override or Default policy configuration.
type BackendTrafficPolicySpecApplyConfiguration struct {
	// TargetRefs identifies API object(s) to apply this policy to.
	// Currently, Backends (A grouping of like endpoints such as Service,
	// ServiceImport, or any implementation-specific backendRef) are the only
	// valid API target references.
	//
	// Currently, a TargetRef cannot be scoped to a specific port on a
	// Service.
	TargetRefs []v1.LocalPolicyTargetReferenceApplyConfiguration `json:"targetRefs,omitempty"`
	// RetryConstraint defines the configuration for when to allow or prevent
	// further retries to a target backend, by dynamically calculating a 'retry
	// budget'. This budget is calculated based on the percentage of incoming
	// traffic composed of retries over a given time interval. Once the budget
	// is exceeded, additional retries will be rejected.
	//
	// For example, if the retry budget interval is 10 seconds, there have been
	// 1000 active requests in the past 10 seconds, and the allowed percentage
	// of requests that can be retried is 20% (the default), then 200 of those
	// requests may be composed of retries. Active requests will only be
	// considered for the duration of the interval when calculating the retry
	// budget. Retrying the same original request multiple times within the
	// retry budget interval will lead to each retry being counted towards
	// calculating the budget.
	//
	// Configuring a RetryConstraint in BackendTrafficPolicy is compatible with
	// HTTPRoute Retry settings for each HTTPRouteRule that targets the same
	// backend. While the HTTPRouteRule Retry stanza can specify whether a
	// request will be retried, and the number of retry attempts each client
	// may perform, RetryConstraint helps prevent cascading failures such as
	// retry storms during periods of consistent failures.
	//
	// After the retry budget has been exceeded, additional retries to the
	// backend MUST return a 503 response to the client.
	//
	// Additional configurations for defining a constraint on retries MAY be
	// defined in the future.
	//
	// Support: Extended
	//
	// <gateway:experimental>
	RetryConstraint *RetryConstraintApplyConfiguration `json:"retryConstraint,omitempty"`
	// SessionPersistence defines and configures session persistence
	// for the backend.
	//
	// Support: Extended
	SessionPersistence *v1.SessionPersistenceApplyConfiguration `json:"sessionPersistence,omitempty"`
}

// BackendTrafficPolicySpecApplyConfiguration constructs a declarative configuration of the BackendTrafficPolicySpec type for use with
// apply.
func BackendTrafficPolicySpec() *BackendTrafficPolicySpecApplyConfiguration {
	return &BackendTrafficPolicySpecApplyConfiguration{}
}

// WithTargetRefs adds the given value to the TargetRefs field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the TargetRefs field.
func (b *BackendTrafficPolicySpecApplyConfiguration) WithTargetRefs(values ...*v1.LocalPolicyTargetReferenceApplyConfiguration) *BackendTrafficPolicySpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithTargetRefs")
		}
		b.TargetRefs = append(b.TargetRefs, *values[i])
	}
	return b
}

// WithRetryConstraint sets the RetryConstraint field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the RetryConstraint field is set to the value of the last call.
func (b *BackendTrafficPolicySpecApplyConfiguration) WithRetryConstraint(value *RetryConstraintApplyConfiguration) *BackendTrafficPolicySpecApplyConfiguration {
	b.RetryConstraint = value
	return b
}

// WithSessionPersistence sets the SessionPersistence field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SessionPersistence field is set to the value of the last call.
func (b *BackendTrafficPolicySpecApplyConfiguration) WithSessionPersistence(value *v1.SessionPersistenceApplyConfiguration) *BackendTrafficPolicySpecApplyConfiguration {
	b.SessionPersistence = value
	return b
}
